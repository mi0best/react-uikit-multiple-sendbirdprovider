import {
  Button,
  ButtonTypes,
  Icon,
  IconColors,
  IconTypes,
  K,
  K2,
  Label,
  LabelColors,
  LabelStringSet,
  LabelTypography,
  LocalizationContext,
  OutgoingMessageStates,
  S3 as S,
  W,
  __assign,
  __extends,
  __spreadArray,
  _objectSpread2,
  defaultLocale,
  filterMessageListParams,
  getCaseResolvedThreadReplySelectType,
  getClassName,
  getOutgoingMessageState,
  isAudio,
  isGif,
  isImage,
  isMultipleFilesMessage,
  isReadMessage,
  isSendableMessage,
  isSentStatus,
  isVideo,
  isVoiceMessageMimeType,
  noop,
  qe2 as qe,
  require_prop_types,
  useLocalization,
  useMediaQueryContext,
  useSendbirdStateContext,
  uuidv4,
  xe
} from "./chunk-AKEMRQJX.js";
import {
  META_ARRAY_MESSAGE_TYPE_KEY,
  META_ARRAY_MESSAGE_TYPE_VALUE__VOICE,
  META_ARRAY_VOICE_DURATION_KEY,
  VOICE_MESSAGE_FILE_NAME,
  VOICE_MESSAGE_MIME_TYPE
} from "./chunk-ZUUM5UVF.js";
import {
  require_react_dom
} from "./chunk-OCHDJWGW.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@sendbird/uikit-react/pubSub/topics.js
var PUBSUB_TOPICS = {
  // Group Channel
  USER_UPDATED: "USER_UPDATED",
  SEND_MESSAGE_START: "SEND_MESSAGE_START",
  SEND_MESSAGE_FAILED: "SEND_MESSAGE_FAILED",
  SEND_USER_MESSAGE: "SEND_USER_MESSAGE",
  SEND_FILE_MESSAGE: "SEND_FILE_MESSAGE",
  ON_FILE_INFO_UPLOADED: "ON_FILE_INFO_UPLOADED",
  UPDATE_USER_MESSAGE: "UPDATE_USER_MESSAGE",
  DELETE_MESSAGE: "DELETE_MESSAGE",
  LEAVE_CHANNEL: "LEAVE_CHANNEL",
  CREATE_CHANNEL: "CREATE_CHANNEL",
  // Open Channel
  UPDATE_OPEN_CHANNEL: "UPDATE_OPEN_CHANNEL"
};

// node_modules/@sendbird/uikit-react/UserProfileContext-2001a468.js
var import_react = __toESM(require_react(), 1);
var UserProfileContext = import_react.default.createContext({
  disableUserProfile: true,
  isOpenChannel: false,
  renderUserProfile: null,
  onUserProfileMessage: null
});
var UserProfileProvider = function(_a) {
  var _b = _a.isOpenChannel, isOpenChannel = _b === void 0 ? false : _b, _c = _a.disableUserProfile, disableUserProfile = _c === void 0 ? false : _c, _d = _a.renderUserProfile, renderUserProfile = _d === void 0 ? null : _d, _e = _a.onUserProfileMessage, onUserProfileMessage = _e === void 0 ? null : _e, children = _a.children;
  return import_react.default.createElement(UserProfileContext.Provider, {
    value: {
      isOpenChannel,
      disableUserProfile,
      renderUserProfile,
      onUserProfileMessage
    }
  }, children);
};

// node_modules/@sendbird/uikit-react/ui/ImageRenderer.js
var import_react2 = __toESM(require_react(), 1);
var numberToPx = function(value) {
  return typeof value === "number" ? "".concat(value, "px") : value;
};
function getDynamicMinLengthInPx(sideLength, maxSideLength, defaultMinLength) {
  var _a;
  return "min(".concat(maxSideLength !== null && maxSideLength !== void 0 ? maxSideLength : defaultMinLength, ", ").concat((_a = numberToPx(sideLength)) !== null && _a !== void 0 ? _a : defaultMinLength, ")");
}
function useDynamicSideLength(_a) {
  var width = _a.width, height = _a.height, maxSideLength = _a.maxSideLength, defaultMinLength = _a.defaultMinLength;
  var dynamicMinWidth = (0, import_react2.useMemo)(function() {
    return getDynamicMinLengthInPx(width, maxSideLength, defaultMinLength);
  }, [width]);
  var dynamicMinHeight = (0, import_react2.useMemo)(function() {
    return getDynamicMinLengthInPx(height, maxSideLength, defaultMinLength);
  }, [height]);
  return [dynamicMinWidth, dynamicMinHeight];
}
function getBorderRadiusForImageRenderer(circle, borderRadius) {
  if (circle === void 0) {
    circle = false;
  }
  if (borderRadius === void 0) {
    borderRadius = null;
  }
  return circle ? "50%" : numberToPx(borderRadius);
}
function getBorderRadiusForMultipleImageRenderer(borderRadius, index, totalCount) {
  var value = parseInt(borderRadius);
  var lastIndex = totalCount - 1;
  var topLeft = index === 0 ? value * 2 : value;
  var topRight = index === 1 ? value * 2 : value;
  var bottomRight = index === lastIndex ? value * 2 : value;
  var bottomLeft = index === lastIndex - 1 ? value * 2 : value;
  return "".concat(topLeft, "px ").concat(topRight, "px ").concat(bottomRight, "px ").concat(bottomLeft, "px");
}
var ImageRenderer = function(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, url = _a.url, _c = _a.alt, alt = _c === void 0 ? "" : _c, _d = _a.width, width = _d === void 0 ? null : _d, _e = _a.maxSideLength, maxSideLength = _e === void 0 ? null : _e, _f = _a.height, height = _f === void 0 ? null : _f, _g = _a.circle, circle = _g === void 0 ? false : _g, _h = _a.fixedSize, fixedSize = _h === void 0 ? false : _h, _j = _a.placeHolder, placeHolder = _j === void 0 ? null : _j, _k = _a.defaultComponent, defaultComponent = _k === void 0 ? null : _k, _l = _a.borderRadius, borderRadius = _l === void 0 ? null : _l, _m = _a.onLoad, onLoad = _m === void 0 ? function() {
  } : _m, _o = _a.onError, onError = _o === void 0 ? function() {
  } : _o, shadeOnHover = _a.shadeOnHover, _p = _a.isUploaded, isUploaded = _p === void 0 ? true : _p;
  var _q = (0, import_react2.useState)(false), showDefaultComponent = _q[0], setShowDefaultComponent = _q[1];
  var _r = (0, import_react2.useState)(true), showPlaceHolder = _r[0], setShowPlaceHolder = _r[1];
  var _s2 = useDynamicSideLength({
    width,
    height,
    maxSideLength,
    defaultMinLength: "400px"
  }), dynamicMinWidth = _s2[0], dynamicMinHeight = _s2[1];
  var DefaultComponent2 = (0, import_react2.useMemo)(function() {
    return typeof defaultComponent === "function" ? defaultComponent() : defaultComponent;
  }, [defaultComponent]);
  var PlaceHolder2 = (0, import_react2.useMemo)(function() {
    return placeHolder && typeof placeHolder === "function" ? placeHolder({
      style: {
        width: "100%",
        minWidth: dynamicMinWidth,
        maxWidth: fixedSize ? dynamicMinWidth : "400px",
        height: dynamicMinHeight,
        position: "absolute",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }) : null;
  }, [placeHolder]);
  var HiddenImageLoader = (0, import_react2.useMemo)(function() {
    setShowDefaultComponent(false);
    return import_react2.default.createElement("img", {
      className: "sendbird-image-renderer__hidden-image-loader",
      src: url,
      alt,
      onLoad: function() {
        setShowPlaceHolder(false);
        onLoad();
      },
      onError: function() {
        setShowDefaultComponent(true);
        onError();
      }
    });
  }, [url]);
  return dynamicMinWidth && dynamicMinHeight && import_react2.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-image-renderer"], false).join(" "),
    style: {
      width: "100%",
      minWidth: dynamicMinWidth,
      maxWidth: fixedSize ? dynamicMinWidth : "400px",
      height: dynamicMinHeight
    }
  }, showPlaceHolder && PlaceHolder2, showDefaultComponent ? DefaultComponent2 : import_react2.default.createElement("div", {
    className: "sendbird-image-renderer__image",
    style: {
      width: "100%",
      minWidth: dynamicMinWidth,
      maxWidth: fixedSize ? dynamicMinWidth : "400px",
      height: dynamicMinHeight,
      position: "absolute",
      backgroundRepeat: "no-repeat",
      backgroundPosition: "center",
      backgroundSize: "cover",
      backgroundImage: "url(".concat(url, ")"),
      borderRadius: getBorderRadiusForImageRenderer(circle, borderRadius)
    }
  }), HiddenImageLoader, shadeOnHover && import_react2.default.createElement("div", {
    className: "sendbird-multiple-files-image-renderer__image-cover",
    style: __assign({
      borderRadius: getBorderRadiusForImageRenderer(circle, borderRadius)
    }, isUploaded ? {} : {
      display: "inline-flex"
    })
  }));
};

// node_modules/@sendbird/uikit-react/ui/Avatar.js
var import_react3 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);
var pxToNumber = function(px) {
  if (typeof px === "number") {
    return px;
  }
  if (typeof px === "string") {
    var parsed = Number.parseFloat(px);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
};
var imageRendererClassName = "sendbird-avatar-img";
var DefaultComponent = function(_a) {
  var width = _a.width, height = _a.height;
  var iconWidth = pxToNumber(width);
  var iconHeight = pxToNumber(height);
  if (typeof iconWidth === "number") {
    iconWidth *= 0.575;
  }
  if (typeof iconHeight === "number") {
    iconHeight *= 0.575;
  }
  return import_react3.default.createElement("div", {
    className: "sendbird-avatar-img--default",
    style: {
      width,
      height
    }
  }, import_react3.default.createElement(Icon, {
    type: IconTypes.USER,
    fillColor: IconColors.CONTENT,
    width: iconWidth,
    height: iconHeight
  }));
};
var _defaultComponent = function(_a) {
  var width = _a.width, height = _a.height;
  return import_react3.default.createElement(DefaultComponent, {
    width,
    height
  });
};
var AvatarInner = function(_a) {
  var _b = _a.src, src = _b === void 0 ? "" : _b, _c = _a.alt, alt = _c === void 0 ? "" : _c, height = _a.height, width = _a.width, customDefaultComponent = _a.customDefaultComponent;
  var defaultComponent = function() {
    return customDefaultComponent ? customDefaultComponent({
      width,
      height
    }) : _defaultComponent({
      width,
      height
    });
  };
  if (typeof src === "string") {
    return import_react3.default.createElement(ImageRenderer, {
      className: imageRendererClassName,
      url: src,
      height,
      width,
      alt,
      defaultComponent
    });
  }
  if (src && src.length) {
    if (src.length === 1) {
      return import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[0],
        height,
        width,
        alt,
        defaultComponent
      });
    }
    if (src.length === 2) {
      return import_react3.default.createElement("div", {
        className: "sendbird-avatar--inner__two-child"
      }, import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[0],
        height,
        width,
        alt,
        defaultComponent
      }), import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[1],
        height,
        width,
        alt,
        defaultComponent
      }));
    }
    if (src.length === 3) {
      return import_react3.default.createElement(import_react3.default.Fragment, null, import_react3.default.createElement("div", {
        className: "sendbird-avatar--inner__three-child--upper"
      }, import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[0],
        height,
        width,
        alt,
        defaultComponent
      })), import_react3.default.createElement("div", {
        className: "sendbird-avatar--inner__three-child--lower"
      }, import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[1],
        height,
        width,
        alt,
        defaultComponent
      }), import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: src[2],
        height,
        width,
        alt,
        defaultComponent
      })));
    }
    return import_react3.default.createElement("div", {
      className: "sendbird-avatar--inner__four-child"
    }, src.slice(0, 4).map(function(i2) {
      return import_react3.default.createElement(ImageRenderer, {
        className: imageRendererClassName,
        url: i2,
        height,
        width,
        alt,
        key: uuidv4(),
        defaultComponent
      });
    }));
  }
  return import_react3.default.createElement(ImageRenderer, {
    className: imageRendererClassName,
    url: "",
    height,
    width,
    alt,
    defaultComponent
  });
};
function Avatar(_a, ref) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.src, src = _c === void 0 ? "" : _c, _d = _a.alt, alt = _d === void 0 ? "" : _d, _e = _a.width, width = _e === void 0 ? "56px" : _e, _f = _a.height, height = _f === void 0 ? "56px" : _f, onClick = _a.onClick, customDefaultComponent = _a.customDefaultComponent;
  return import_react3.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-avatar"], false).join(" "),
    role: "button",
    ref,
    style: {
      height,
      width
    },
    onClick,
    onKeyDown: onClick,
    tabIndex: 0
  }, import_react3.default.createElement(AvatarInner, {
    src,
    width,
    height,
    alt,
    customDefaultComponent
  }));
}
var Avatar$1 = import_react3.default.forwardRef(Avatar);

// node_modules/@sendbird/uikit-react/sendbirdSelectors.js
var getSdk = function(state) {
  var _a = state.stores, stores = _a === void 0 ? {} : _a;
  var _b = stores.sdkStore, sdkStore = _b === void 0 ? {} : _b;
  var sdk = sdkStore.sdk;
  return sdk;
};
var getPubSub = function(state) {
  var _a = state.config, config = _a === void 0 ? {} : _a;
  var pubSub = config.pubSub;
  return pubSub;
};
var getCreateGroupChannel = function(state) {
  return function(params) {
    return new Promise(function(resolve, reject) {
      var sdk = getSdk(state);
      var pubSub = getPubSub(state);
      if (!sdk) {
        reject(new Error("Sdk not found"));
      }
      if (!sdk.groupChannel) {
        reject(new Error("Not found GroupChannelModule"));
      }
      if (!(sdk.groupChannel.createChannel && typeof sdk.groupChannel.createChannel === "function")) {
        reject(new Error('Not found the function "createChannel"'));
      }
      sdk.groupChannel.createChannel(params).then(function(channel) {
        resolve(channel);
        pubSub.publish(PUBSUB_TOPICS.CREATE_CHANNEL, {
          channel
        });
      }).catch(reject);
    });
  };
};
var UikitMessageHandler = (
  /** @class */
  function() {
    function UikitMessageHandler2() {
      this._onPending = noop;
      this._onFailed = noop;
      this._onSucceeded = noop;
    }
    UikitMessageHandler2.prototype.triggerPending = function(message) {
      this._onPending(message);
    };
    UikitMessageHandler2.prototype.triggerFailed = function(error, message) {
      this._onFailed(error, message.isResendable ? message : null);
    };
    UikitMessageHandler2.prototype.triggerSucceeded = function(message) {
      this._onSucceeded(message);
    };
    UikitMessageHandler2.prototype.onPending = function(handler) {
      if (typeof handler === "function") {
        this._onPending = handler;
      }
      return this;
    };
    UikitMessageHandler2.prototype.onFailed = function(handler) {
      if (typeof handler === "function") {
        this._onFailed = handler;
      }
      return this;
    };
    UikitMessageHandler2.prototype.onSucceeded = function(handler) {
      if (typeof handler === "function") {
        this._onSucceeded = handler;
      }
      return this;
    };
    return UikitMessageHandler2;
  }()
);

// node_modules/@sendbird/uikit-react/ui/MutedAvatarOverlay.js
var import_react4 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);
function MutedAvatarOverlay(props) {
  var _a = props.height, height = _a === void 0 ? 24 : _a, _b = props.width, width = _b === void 0 ? 24 : _b;
  return import_react4.default.createElement("div", {
    className: "sendbird-muted-avatar",
    style: {
      height: "".concat(height, "px"),
      width: "".concat(width, "px")
    }
  }, import_react4.default.createElement("div", {
    className: "sendbird-muted-avatar__icon"
  }, import_react4.default.createElement("div", {
    className: "sendbird-muted-avatar__bg",
    style: {
      height: "".concat(height, "px"),
      width: "".concat(width, "px")
    }
  }), import_react4.default.createElement(Icon, {
    type: IconTypes.MUTE,
    fillColor: IconColors.WHITE,
    width: "".concat(height - 8, "px"),
    height: "".concat(width - 8, "px")
  })));
}

// node_modules/@sendbird/uikit-react/ui/Checkbox.js
var import_react5 = __toESM(require_react(), 1);
function Checkbox(_a) {
  var id = _a.id, _b = _a.checked, checked = _b === void 0 ? false : _b, disabled = _a.disabled, onChange = _a.onChange;
  var _c = (0, import_react5.useState)(checked), isChecked = _c[0], setIsCheck = _c[1];
  return import_react5.default.createElement("label", {
    className: ["sendbird-checkbox", disabled ? "disabled" : ""].join(" "),
    htmlFor: id
  }, import_react5.default.createElement("input", {
    disabled,
    id,
    type: "checkbox",
    checked: isChecked,
    onClick: function() {
      if (!disabled)
        setIsCheck(!isChecked);
    },
    onChange
  }), import_react5.default.createElement("span", {
    className: ["sendbird-checkbox--checkmark", disabled ? "disabled" : ""].join(" ")
  }));
}

// node_modules/@sendbird/uikit-react/ui/UserProfile.js
var import_react6 = __toESM(require_react(), 1);
var import_prop_types3 = __toESM(require_prop_types(), 1);
function UserProfile(_a) {
  var _b, _c;
  var user = _a.user, currentUserId = _a.currentUserId, _d = _a.disableMessaging, disableMessaging = _d === void 0 ? false : _d, onSuccess = _a.onSuccess;
  var store = useSendbirdStateContext();
  var createChannel = getCreateGroupChannel(store);
  var logger = (_b = store === null || store === void 0 ? void 0 : store.config) === null || _b === void 0 ? void 0 : _b.logger;
  var stringSet = (0, import_react6.useContext)(LocalizationContext).stringSet;
  var currentUserId_ = currentUserId || ((_c = store === null || store === void 0 ? void 0 : store.config) === null || _c === void 0 ? void 0 : _c.userId);
  var onUserProfileMessage = (0, import_react6.useContext)(UserProfileContext).onUserProfileMessage;
  return import_react6.default.createElement("div", {
    className: "sendbird__user-profile"
  }, import_react6.default.createElement("section", {
    className: "sendbird__user-profile-avatar"
  }, import_react6.default.createElement(Avatar$1, {
    height: "80px",
    width: "80px",
    src: user === null || user === void 0 ? void 0 : user.profileUrl
  })), import_react6.default.createElement("section", {
    className: "sendbird__user-profile-name"
  }, import_react6.default.createElement(Label, {
    type: LabelTypography.H_2,
    color: LabelColors.ONBACKGROUND_1
  }, (user === null || user === void 0 ? void 0 : user.nickname) || stringSet.NO_NAME)), (user === null || user === void 0 ? void 0 : user.userId) !== currentUserId_ && !disableMessaging && import_react6.default.createElement("section", {
    className: "sendbird__user-profile-message"
  }, import_react6.default.createElement(Button, {
    type: ButtonTypes.SECONDARY,
    onClick: function() {
      var params = {
        isDistinct: false,
        invitedUserIds: [user === null || user === void 0 ? void 0 : user.userId],
        operatorUserIds: [currentUserId_]
      };
      onSuccess();
      createChannel(params).then(function(groupChannel) {
        logger.info("UserProfile, channel create", groupChannel);
        if (typeof onUserProfileMessage === "function") {
          onUserProfileMessage === null || onUserProfileMessage === void 0 ? void 0 : onUserProfileMessage(groupChannel);
        }
      });
    }
  }, stringSet.USER_PROFILE__MESSAGE)), import_react6.default.createElement("div", {
    className: "sendbird__user-profile-separator"
  }), import_react6.default.createElement("section", {
    className: "sendbird__user-profile-userId"
  }, import_react6.default.createElement(Label, {
    className: "sendbird__user-profile-userId--label",
    type: LabelTypography.CAPTION_2,
    color: LabelColors.ONBACKGROUND_2
  }, stringSet.USER_PROFILE__USER_ID), import_react6.default.createElement(Label, {
    className: "sendbird__user-profile-userId--value",
    type: LabelTypography.BODY_1,
    color: LabelColors.ONBACKGROUND_1
  }, user === null || user === void 0 ? void 0 : user.userId)));
}

// node_modules/@sendbird/uikit-react/ui/SortByRow.js
var import_react7 = __toESM(require_react(), 1);
var componentClassName = "sendbird-sort-by-row";
function SortByRow(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, maxItemCount = _a.maxItemCount, itemWidth = _a.itemWidth, itemHeight = _a.itemHeight, children = _a.children;
  if (Array.isArray(children) && children.length > maxItemCount) {
    var result = [];
    for (var i2 = 0; i2 < children.length; i2 += maxItemCount) {
      result.push(import_react7.default.createElement("div", {
        className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [componentClassName], false).join(" "),
        key: uuidv4(),
        style: {
          width: itemWidth * maxItemCount,
          height: itemHeight
        }
      }, children.slice(i2, i2 + maxItemCount)));
    }
    return import_react7.default.createElement(import_react7.default.Fragment, null, result);
  }
  return import_react7.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [componentClassName], false).join(" "),
    style: {
      width: itemWidth * (Array.isArray(children) ? children.length : 1),
      height: itemHeight
    }
  }, children);
}

// node_modules/@sendbird/uikit-react/ui/ContextMenu.js
var import_react8 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_prop_types4 = __toESM(require_prop_types(), 1);
var HEIGHT_PADDING = 60;
var MenuItems$1 = (
  /** @class */
  function(_super) {
    __extends(MenuItems2, _super);
    function MenuItems2(props) {
      var _this = _super.call(this, props) || this;
      _this.menuRef = import_react8.default.createRef();
      _this.setupEvents = function() {
        var closeDropdown = _this.props.closeDropdown;
        var menuRef = _this.menuRef;
        var handleClickOutside = function(event) {
          var _a, _b;
          if ((menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) && !((_b = (_a = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a === void 0 ? void 0 : _a.contains) === null || _b === void 0 ? void 0 : _b.call(_a, event.target))) {
            closeDropdown === null || closeDropdown === void 0 ? void 0 : closeDropdown();
          }
        };
        _this.setState({
          handleClickOutside
        });
        document.addEventListener("mousedown", handleClickOutside);
      };
      _this.cleanUpEvents = function() {
        var handleClickOutside = _this.state.handleClickOutside;
        document.removeEventListener("mousedown", handleClickOutside);
      };
      _this.getMenuPosition = function() {
        var _a, _b;
        var _c = _this.props, parentRef = _c.parentRef, openLeft = _c.openLeft;
        var parentRect = (_b = (_a = parentRef === null || parentRef === void 0 ? void 0 : parentRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect) === null || _b === void 0 ? void 0 : _b.call(_a);
        var x2 = (parentRect === null || parentRect === void 0 ? void 0 : parentRect.x) || (parentRect === null || parentRect === void 0 ? void 0 : parentRect.left) || 0;
        var y3 = (parentRect === null || parentRect === void 0 ? void 0 : parentRect.y) || (parentRect === null || parentRect === void 0 ? void 0 : parentRect.top) || 0;
        var menuStyle = {
          top: y3,
          left: x2
        };
        if (!_this.menuRef.current)
          return menuStyle;
        var innerWidth = window.innerWidth, innerHeight = window.innerHeight;
        var rect = _this.menuRef.current.getBoundingClientRect();
        if (y3 + rect.height + HEIGHT_PADDING > innerHeight) {
          menuStyle.top -= rect.height;
        }
        if (x2 + rect.width > innerWidth && !openLeft) {
          menuStyle.left -= rect.width;
        }
        if (menuStyle.top < 0) {
          menuStyle.top = rect.height < innerHeight ? (innerHeight - rect.height) / 2 : 0;
        }
        menuStyle.top += 32;
        if (openLeft) {
          var padding = Number.isNaN(rect.width - 30) ? 108 : rect.width - 30;
          menuStyle.left -= padding;
        }
        if (menuStyle.left < 0) {
          menuStyle.left = rect.width < innerWidth ? (innerWidth - rect.width) / 2 : 0;
        }
        _this.setState({
          menuStyle
        });
        return menuStyle;
      };
      _this.state = {
        menuStyle: {},
        handleClickOutside: function() {
        }
      };
      return _this;
    }
    MenuItems2.prototype.componentDidMount = function() {
      this.setupEvents();
      this.getMenuPosition();
    };
    MenuItems2.prototype.componentWillUnmount = function() {
      this.cleanUpEvents();
    };
    MenuItems2.prototype.render = function() {
      var _a;
      var menuStyle = this.state.menuStyle;
      var _b = this.props, children = _b.children, style = _b.style, _c = _b.className, className = _c === void 0 ? "" : _c;
      return (0, import_react_dom.createPortal)(import_react8.default.createElement("div", {
        className: (_a = this.props) === null || _a === void 0 ? void 0 : _a.className
      }, import_react8.default.createElement("div", {
        className: "sendbird-dropdown__menu-backdrop"
      }), import_react8.default.createElement("ul", {
        className: "".concat(className, " sendbird-dropdown__menu"),
        ref: this.menuRef,
        style: __assign({
          display: "inline-block",
          position: "fixed",
          left: "".concat(Math.round(menuStyle.left), "px"),
          top: "".concat(Math.round(menuStyle.top), "px")
        }, style)
      }, children)), document.getElementById("sendbird-dropdown-portal"));
    };
    return MenuItems2;
  }(import_react8.default.Component)
);
var defaultParentRect = {
  x: 0,
  y: 0,
  left: 0,
  top: 0,
  height: 0
};
var EmojiListItems$1 = function(_a) {
  var children = _a.children, parentRef = _a.parentRef, parentContainRef = _a.parentContainRef, _b = _a.spaceFromTrigger, spaceFromTrigger = _b === void 0 ? {
    x: 0,
    y: 0
  } : _b, closeDropdown = _a.closeDropdown;
  var _c = (0, import_react8.useState)({
    left: 0,
    top: 0
  }), reactionStyle = _c[0], setReactionStyle = _c[1];
  var reactionRef = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(function() {
    if (parentContainRef && (parentContainRef === null || parentContainRef === void 0 ? void 0 : parentContainRef.current)) {
      parentContainRef.current.classList.add("sendbird-reactions--pressed");
    }
    return function() {
      if (parentContainRef && (parentContainRef === null || parentContainRef === void 0 ? void 0 : parentContainRef.current)) {
        parentContainRef.current.classList.remove("sendbird-reactions--pressed");
      }
    };
  }, []);
  (0, import_react8.useEffect)(function() {
    var handleClickOutSide = function(event) {
      var _a2, _b2;
      if ((reactionRef === null || reactionRef === void 0 ? void 0 : reactionRef.current) && !((_b2 = (_a2 = reactionRef === null || reactionRef === void 0 ? void 0 : reactionRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event.target))) {
        closeDropdown();
      }
    };
    document.addEventListener("mousedown", handleClickOutSide);
    return function() {
      document.removeEventListener("mousedown", handleClickOutSide);
    };
  }, []);
  (0, import_react8.useEffect)(function() {
    var _a2, _b2, _c2;
    var spaceFromTriggerX = (spaceFromTrigger === null || spaceFromTrigger === void 0 ? void 0 : spaceFromTrigger.x) || 0;
    var spaceFromTriggerY = (spaceFromTrigger === null || spaceFromTrigger === void 0 ? void 0 : spaceFromTrigger.y) || 0;
    var parentRect = (_b2 = (_a2 = parentRef === null || parentRef === void 0 ? void 0 : parentRef.current) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) !== null && _b2 !== void 0 ? _b2 : defaultParentRect;
    var x2 = parentRect.x || parentRect.left;
    var y3 = parentRect.y || parentRect.top;
    var reactionStyle2 = {
      top: y3,
      left: x2
    };
    if (!(reactionRef === null || reactionRef === void 0 ? void 0 : reactionRef.current)) {
      setReactionStyle(reactionStyle2);
    } else {
      var rect = (_c2 = reactionRef === null || reactionRef === void 0 ? void 0 : reactionRef.current) === null || _c2 === void 0 ? void 0 : _c2.getBoundingClientRect();
      if (reactionStyle2.top < rect.height) {
        reactionStyle2.top += parentRect.height;
        reactionStyle2.top += spaceFromTriggerY;
      } else {
        reactionStyle2.top -= rect.height;
        reactionStyle2.top -= spaceFromTriggerY;
      }
      reactionStyle2.left -= rect.width / 2;
      reactionStyle2.left += parentRect.height / 2 - 2;
      reactionStyle2.left += spaceFromTriggerX;
      var maximumLeft = window.innerWidth - rect.width;
      if (maximumLeft < reactionStyle2.left) {
        reactionStyle2.left = maximumLeft;
      }
      if (reactionStyle2.left < 0) {
        reactionStyle2.left = 0;
      }
      setReactionStyle(reactionStyle2);
    }
  }, []);
  var rootElement = document.getElementById("sendbird-emoji-list-portal");
  if (rootElement) {
    return (0, import_react_dom.createPortal)(import_react8.default.createElement(import_react8.default.Fragment, null, import_react8.default.createElement("div", {
      className: "sendbird-dropdown__menu-backdrop"
    }), import_react8.default.createElement("ul", {
      className: "sendbird-dropdown__reaction-bar",
      ref: reactionRef,
      style: {
        display: "inline-block",
        position: "fixed",
        left: "".concat(Math.round(reactionStyle.left), "px"),
        top: "".concat(Math.round(reactionStyle.top), "px")
      }
    }, import_react8.default.createElement(SortByRow, {
      className: "sendbird-dropdown__reaction-bar__row",
      maxItemCount: 8,
      itemWidth: 44,
      itemHeight: 40
    }, children))), rootElement);
  }
  return null;
};
var ENTER_KEY = 13;
var MenuItems = MenuItems$1;
var EmojiListItems = EmojiListItems$1;
var MenuItem = function(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, children = _a.children, onClick = _a.onClick, _c = _a.disable, disable = _c === void 0 ? false : _c, _d = _a.dataSbId, dataSbId = _d === void 0 ? "" : _d;
  var handleClickEvent = function(e2) {
    if (!disable && onClick) {
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    }
  };
  return import_react8.default.createElement("li", {
    className: getClassName([className, "sendbird-dropdown__menu-item", disable ? "disable" : ""]),
    role: "menuitem",
    "aria-disabled": disable ? true : false,
    onClick: handleClickEvent,
    onKeyPress: function(e2) {
      if (e2.keyCode === ENTER_KEY)
        handleClickEvent(e2);
    },
    tabIndex: 0,
    "data-sb-id": dataSbId
  }, import_react8.default.createElement(Label, {
    className: "sendbird-dropdown__menu-item__text",
    type: LabelTypography.SUBTITLE_2,
    color: disable ? LabelColors.ONBACKGROUND_4 : LabelColors.ONBACKGROUND_1
  }, children));
};
function ContextMenu(_a) {
  var menuTrigger = _a.menuTrigger, menuItems = _a.menuItems, isOpen = _a.isOpen, onClick = _a.onClick;
  var _b = (0, import_react8.useState)(false), showMenu = _b[0], setShowMenu = _b[1];
  return import_react8.default.createElement("div", {
    className: "sendbird-context-menu",
    style: {
      display: "inline"
    },
    onClick
  }, menuTrigger === null || menuTrigger === void 0 ? void 0 : menuTrigger(function() {
    return setShowMenu(!showMenu);
  }), (showMenu || isOpen) && menuItems(function() {
    return setShowMenu(false);
  }));
}

// node_modules/@sendbird/uikit-react/ui/UserListItem.js
var import_react9 = __toESM(require_react(), 1);
var import_prop_types5 = __toESM(require_prop_types(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
function UserListItem(_a) {
  var user = _a.user, className = _a.className, checked = _a.checked, checkBox = _a.checkBox, isOperator2 = _a.isOperator, disabled = _a.disabled, disableMessaging = _a.disableMessaging, currentUser = _a.currentUser, action = _a.action, onChange = _a.onChange, _b = _a.avatarSize, avatarSize = _b === void 0 ? "40px" : _b, onClick = _a.onClick;
  var uniqueKey = user.userId;
  var actionRef = import_react9.default.useRef(null);
  var parentRef = import_react9.default.useRef(null);
  var avatarRef = import_react9.default.useRef(null);
  var _c = (0, import_react9.useContext)(UserProfileContext), disableUserProfile = _c.disableUserProfile, renderUserProfile = _c.renderUserProfile;
  var stringSet = (0, import_react9.useContext)(LocalizationContext).stringSet;
  return import_react9.default.createElement(
    "div",
    {
      className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-user-list-item"], false).join(" "),
      ref: parentRef
    },
    (user === null || user === void 0 ? void 0 : user.isMuted) && import_react9.default.createElement(MutedAvatarOverlay, {
      height: 40,
      width: 40
    }),
    import_react9.default.createElement(ContextMenu, {
      menuTrigger: function(toggleDropdown) {
        return import_react9.default.createElement(Avatar$1, {
          className: "sendbird-user-list-item__avatar",
          ref: avatarRef,
          src: user.profileUrl,
          width: avatarSize,
          height: avatarSize,
          onClick: function() {
            if (!disableUserProfile) {
              toggleDropdown();
              onClick === null || onClick === void 0 ? void 0 : onClick();
            }
          }
        });
      },
      menuItems: function(closeDropdown) {
        return import_react9.default.createElement(MenuItems, {
          openLeft: true,
          parentRef: avatarRef,
          parentContainRef: avatarRef,
          closeDropdown,
          style: {
            paddingTop: "0px",
            paddingBottom: "0px"
          }
        }, renderUserProfile ? renderUserProfile({
          user,
          currentUserId: currentUser,
          close: closeDropdown
        }) : import_react9.default.createElement(UserProfile, {
          disableMessaging,
          user,
          currentUserId: currentUser,
          onSuccess: closeDropdown
        }));
      }
    }),
    import_react9.default.createElement(Label, {
      className: "sendbird-user-list-item__title",
      type: LabelTypography.SUBTITLE_1,
      color: LabelColors.ONBACKGROUND_1
    }, user.nickname || stringSet.NO_NAME, currentUser === user.userId && " (You)"),
    // if there is now nickname, display userId
    !user.nickname && import_react9.default.createElement(Label, {
      className: "sendbird-user-list-item__subtitle",
      type: LabelTypography.CAPTION_3,
      color: LabelColors.ONBACKGROUND_2
    }, user.userId),
    checkBox && import_react9.default.createElement("label", {
      className: "sendbird-user-list-item__checkbox",
      htmlFor: uniqueKey
    }, import_react9.default.createElement(Checkbox, {
      id: uniqueKey,
      checked,
      disabled,
      onChange: function(event) {
        return onChange(event);
      }
    })),
    isOperator2 && import_react9.default.createElement(Label, {
      className: ["sendbird-user-list-item__operator", checkBox ? "checkbox" : ""].join(" "),
      type: LabelTypography.SUBTITLE_2,
      color: LabelColors.ONBACKGROUND_2
    }, "Operator"),
    action && import_react9.default.createElement("div", {
      className: "sendbird-user-list-item__action",
      ref: actionRef
    }, action({
      actionRef,
      parentRef
    }))
  );
}

// node_modules/@sendbird/uikit-react/utils-2c1f072b.js
var DEFAULT_URL_PREFIX = "https://static.sendbird.com/sample/cover/cover_";
var getChannelAvatarSource = function(channel, currentUserId) {
  if (channel === null || channel === void 0 ? void 0 : channel.coverUrl) {
    if (!new RegExp("^".concat(DEFAULT_URL_PREFIX)).test(channel.coverUrl)) {
      return channel.coverUrl;
    }
  }
  return ((channel === null || channel === void 0 ? void 0 : channel.members) || []).filter(function(member) {
    return member.userId !== currentUserId;
  }).map(function(_a) {
    var profileUrl = _a.profileUrl;
    return profileUrl;
  });
};
var generateDefaultAvatar = function(channel) {
  if (channel === null || channel === void 0 ? void 0 : channel.coverUrl) {
    if (new RegExp("^".concat(DEFAULT_URL_PREFIX)).test(channel.coverUrl)) {
      return true;
    }
    return false;
  }
  return true;
};

// node_modules/@sendbird/uikit-react/ui/ChannelAvatar.js
var import_react10 = __toESM(require_react(), 1);
var import_prop_types6 = __toESM(require_prop_types(), 1);
function ChannelAvatar(_a) {
  var channel = _a.channel, userId = _a.userId, theme = _a.theme, _b = _a.width, width = _b === void 0 ? 56 : _b, _c = _a.height, height = _c === void 0 ? 56 : _c;
  var isBroadcast = channel === null || channel === void 0 ? void 0 : channel.isBroadcast;
  var memoizedAvatar = (0, import_react10.useMemo)(function() {
    return isBroadcast ? generateDefaultAvatar(channel) ? import_react10.default.createElement("div", {
      className: "sendbird-chat-header--default-avatar",
      style: {
        width,
        height,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }, import_react10.default.createElement(Icon, {
      type: IconTypes.BROADCAST,
      fillColor: IconColors.CONTENT,
      width: width * 0.575,
      height: height * 0.575
    })) : import_react10.default.createElement(Avatar$1, {
      className: "sendbird-chat-header--avatar--broadcast-channel",
      src: getChannelAvatarSource(channel, userId),
      width,
      height,
      alt: channel === null || channel === void 0 ? void 0 : channel.name
    }) : import_react10.default.createElement(Avatar$1, {
      className: "sendbird-chat-header--avatar--group-channel",
      src: getChannelAvatarSource(channel, userId),
      width: "".concat(width, "px"),
      height: "".concat(height, "px"),
      alt: channel === null || channel === void 0 ? void 0 : channel.name
    });
  }, [channel === null || channel === void 0 ? void 0 : channel.members, channel === null || channel === void 0 ? void 0 : channel.coverUrl, theme]);
  return import_react10.default.createElement(import_react10.default.Fragment, null, memoizedAvatar);
}

// node_modules/@sendbird/uikit-react/index-2d27aeef.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  // Year
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S2(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token, localize) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$2.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$2.M(date, token);
      case "Mo":
        return localize.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d2(date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$2.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token, localize) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$2.h(date, token);
  },
  // Hour [0-23]
  H: function H2(date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$2.H(date, token);
  },
  // Hour [0-11]
  K: function K3(date, token, localize) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m2(date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$2.m(date, token);
  },
  // Second
  s: function s2(date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$2.s(date, token);
  },
  // Fraction of second
  S: function S3(date, token) {
    return formatters$2.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters$1 = formatters;
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong) {
  switch (pattern) {
    case "P":
      return formatLong.date({
        width: "short"
      });
    case "PP":
      return formatLong.date({
        width: "medium"
      });
    case "PPP":
      return formatLong.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong) {
  switch (pattern) {
    case "p":
      return formatLong.time({
        width: "short"
      });
    case "pp":
      return formatLong.time({
        width: "medium"
      });
    case "ppp":
      return formatLong.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/@sendbird/uikit-react/ui/Loader.js
var import_react11 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);
function Loader(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.width, width = _c === void 0 ? "26px" : _c, _d = _a.height, height = _d === void 0 ? "26px" : _d, children = _a.children;
  return import_react11.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-loader"], false).join(" "),
    style: {
      width: typeof width === "string" ? width : "".concat(width, "px"),
      height: typeof height === "string" ? height : "".concat(height, "px")
    }
  }, children || import_react11.default.createElement(Icon, {
    type: IconTypes.SPINNER,
    width: "26px",
    height: "26px"
  }));
}

// node_modules/@sendbird/uikit-react/index-682a192c.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

// node_modules/@sendbird/uikit-react/index-f8a9cb51.js
function isToday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, Date.now());
}
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
function isThisYear(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameYear(dirtyDate, Date.now());
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function isYesterday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, subDays(Date.now(), 1));
}

// node_modules/@sendbird/uikit-react/index-4b4e9682.js
var import_react12 = __toESM(require_react(), 1);
var getChannelTitle = function(channel, currentUserId, stringSet) {
  var _a;
  if (stringSet === void 0) {
    stringSet = LabelStringSet;
  }
  if (!(channel === null || channel === void 0 ? void 0 : channel.name) && !(channel === null || channel === void 0 ? void 0 : channel.members)) {
    return stringSet.NO_TITLE;
  }
  if ((channel === null || channel === void 0 ? void 0 : channel.name) && channel.name !== "Group Channel") {
    return channel.name;
  }
  if (((_a = channel === null || channel === void 0 ? void 0 : channel.members) === null || _a === void 0 ? void 0 : _a.length) === 1) {
    return stringSet.NO_MEMBERS;
  }
  return ((channel === null || channel === void 0 ? void 0 : channel.members) || []).filter(function(_a2) {
    var userId = _a2.userId;
    return userId !== currentUserId;
  }).map(function(_a2) {
    var nickname = _a2.nickname;
    return nickname || stringSet.NO_NAME;
  }).join(", ");
};
var getLastMessageCreatedAt = function(_a) {
  var _b;
  var channel = _a.channel, locale = _a.locale, _c = _a.stringSet, stringSet = _c === void 0 ? LabelStringSet : _c;
  var createdAt = (_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.createdAt;
  var optionalParam = locale ? {
    locale
  } : null;
  if (!createdAt) {
    return "";
  }
  if (isToday(createdAt)) {
    return format(createdAt, "p", optionalParam);
  }
  if (isYesterday(createdAt)) {
    return stringSet.MESSAGE_STATUS__YESTERDAY || "Yesterday";
  }
  if (isThisYear(createdAt)) {
    return format(createdAt, "MMM d", optionalParam);
  }
  return format(createdAt, "yyyy/M/d", optionalParam);
};
var getTotalMembers = function(channel) {
  return (channel === null || channel === void 0 ? void 0 : channel.memberCount) ? channel.memberCount : 0;
};
var getChannelPreviewFileDisplayString = function(mimeType, stringSet) {
  var _a, _b, _c, _d, _e, _f;
  if (stringSet === void 0) {
    stringSet = LabelStringSet;
  }
  if (isGif(mimeType)) {
    return (_a = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_GIF) !== null && _a !== void 0 ? _a : "";
  }
  if (isImage(mimeType)) {
    return (_b = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_PHOTO) !== null && _b !== void 0 ? _b : "";
  }
  if (isVideo(mimeType)) {
    return (_c = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_VIDEO) !== null && _c !== void 0 ? _c : "";
  }
  if (isAudio(mimeType)) {
    return (_d = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_AUDIO) !== null && _d !== void 0 ? _d : "";
  }
  if (isVoiceMessageMimeType(mimeType)) {
    return (_e = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_VOICE_MESSAGE) !== null && _e !== void 0 ? _e : "";
  }
  return (_f = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_GENERAL) !== null && _f !== void 0 ? _f : "";
};
var getPrettyLastMessage = function(message, stringSet) {
  var _a, _b, _c, _d;
  if (message === void 0) {
    message = null;
  }
  if (stringSet === void 0) {
    stringSet = LabelStringSet;
  }
  if (!message)
    return "";
  if (message.isFileMessage()) {
    return getChannelPreviewFileDisplayString(message.type, stringSet);
  }
  if (message.isMultipleFilesMessage()) {
    var mimeType = (_b = (_a = message.fileInfoList) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.mimeType;
    if (isImage(mimeType) || isGif(mimeType)) {
      return (_c = stringSet === null || stringSet === void 0 ? void 0 : stringSet.CHANNEL_PREVIEW_LAST_MESSAGE_FILE_TYPE_PHOTO) !== null && _c !== void 0 ? _c : "";
    }
    return getChannelPreviewFileDisplayString(mimeType, stringSet);
  }
  return (_d = message.message) !== null && _d !== void 0 ? _d : "";
};
var getLastMessage = function(channel, stringSet) {
  if (stringSet === void 0) {
    stringSet = LabelStringSet;
  }
  return (channel === null || channel === void 0 ? void 0 : channel.lastMessage) ? getPrettyLastMessage(channel === null || channel === void 0 ? void 0 : channel.lastMessage, stringSet) : "";
};
var getChannelUnreadMessageCount = function(channel) {
  return (channel === null || channel === void 0 ? void 0 : channel.unreadMessageCount) ? channel.unreadMessageCount : 0;
};
function MessageStatus(_a) {
  var _b, _c;
  var _d;
  var className = _a.className, message = _a.message, channel = _a.channel, _e = _a.isDateSeparatorConsidered, isDateSeparatorConsidered = _e === void 0 ? true : _e;
  var _f = useLocalization(), stringSet = _f.stringSet, dateLocale = _f.dateLocale;
  var status = getOutgoingMessageState(channel, message);
  var hideMessageStatusIcon = ((_d = channel === null || channel === void 0 ? void 0 : channel.isGroupChannel) === null || _d === void 0 ? void 0 : _d.call(channel)) && (channel.isSuper || channel.isPublic || channel.isBroadcast) && !(status === OutgoingMessageStates.PENDING || status === OutgoingMessageStates.FAILED);
  var iconType = (_b = {}, _b[OutgoingMessageStates.SENT] = IconTypes.DONE, _b[OutgoingMessageStates.DELIVERED] = IconTypes.DONE_ALL, _b[OutgoingMessageStates.READ] = IconTypes.DONE_ALL, _b[OutgoingMessageStates.FAILED] = IconTypes.ERROR, _b);
  var iconColor = (_c = {}, _c[OutgoingMessageStates.SENT] = IconColors.SENT, _c[OutgoingMessageStates.DELIVERED] = IconColors.SENT, _c[OutgoingMessageStates.READ] = IconColors.READ, _c[OutgoingMessageStates.FAILED] = IconColors.ERROR, _c);
  return import_react12.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-message-status"], false).join(" ")
  }, status === OutgoingMessageStates.PENDING ? import_react12.default.createElement(Loader, {
    className: "sendbird-message-status__icon",
    width: "16px",
    height: "16px"
  }, import_react12.default.createElement(Icon, {
    type: IconTypes.SPINNER,
    fillColor: IconColors.PRIMARY,
    width: "16px",
    height: "16px"
  })) : import_react12.default.createElement(Icon, {
    className: "sendbird-message-status__icon ".concat(hideMessageStatusIcon ? "hide-icon" : "", " ").concat(status === OutgoingMessageStates.FAILED ? "" : "sendbird-message-status--sent"),
    type: iconType[status] || IconTypes.ERROR,
    fillColor: iconColor[status],
    width: "16px",
    height: "16px"
  }), isSentStatus(status) && import_react12.default.createElement(Label, {
    className: "sendbird-message-status__text",
    type: LabelTypography.CAPTION_3,
    color: LabelColors.ONBACKGROUND_2
  }, isDateSeparatorConsidered ? format((message === null || message === void 0 ? void 0 : message.createdAt) || 0, "p", {
    locale: dateLocale
  }) : getLastMessageCreatedAt({
    channel,
    locale: dateLocale,
    stringSet
  })));
}

// node_modules/@sendbird/uikit-react/consts-57c888b9.js
var MENTION_USER_LABEL_CLASSNAME = "sendbird-mention-user-label";

// node_modules/@sendbird/uikit-react/color-57373b4c.js
var Colors;
(function(Colors2) {
  Colors2["ONBACKGROUND_1"] = "ONBACKGROUND_1";
  Colors2["ONBACKGROUND_2"] = "ONBACKGROUND_2";
  Colors2["ONBACKGROUND_3"] = "ONBACKGROUND_3";
  Colors2["ONBACKGROUND_4"] = "ONBACKGROUND_4";
  Colors2["ONCONTENT_1"] = "ONCONTENT_1";
  Colors2["ONCONTENT_2"] = "ONCONTENT_2";
  Colors2["PRIMARY"] = "PRIMARY";
  Colors2["ERROR"] = "ERROR";
})(Colors || (Colors = {}));
var changeColorToClassName = function(color) {
  switch (color) {
    case Colors.ONBACKGROUND_1:
      return "sendbird-color--onbackground-1";
    case Colors.ONBACKGROUND_2:
      return "sendbird-color--onbackground-2";
    case Colors.ONBACKGROUND_3:
      return "sendbird-color--onbackground-3";
    case Colors.ONBACKGROUND_4:
      return "sendbird-color--onbackground-4";
    case Colors.ONCONTENT_1:
      return "sendbird-color--oncontent-1";
    case Colors.PRIMARY:
      return "sendbird-color--primary";
    case Colors.ERROR:
      return "sendbird-color--error";
    default:
      return null;
  }
};

// node_modules/@sendbird/uikit-react/ui/TextButton.js
var import_react13 = __toESM(require_react(), 1);
var TextButton = function(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.color, color = _c === void 0 ? Colors.ONBACKGROUND_1 : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, _e = _a.disableUnderline, disableUnderline = _e === void 0 ? false : _e, _f = _a.onClick, onClick = _f === void 0 ? function() {
  } : _f, children = _a.children;
  return import_react13.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [changeColorToClassName(color), disableUnderline ? "sendbird-textbutton--not-underline" : "sendbird-textbutton", disabled ? "sendbird-textbutton--disabled" : ""], false).join(" "),
    role: "button",
    tabIndex: 0,
    onClick: function(e2) {
      return onClick(e2);
    },
    onKeyPress: function(e2) {
      return onClick(e2);
    }
  }, children);
};

// node_modules/@sendbird/uikit-react/const-73db0277.js
var PREV_RESULT_SIZE = 30;
var NEXT_RESULT_SIZE = 15;
var MAX_USER_MENTION_COUNT = 10;
var MAX_USER_SUGGESTION_COUNT = 15;
var USER_MENTION_TEMP_CHAR = "@";
var ThreadReplySelectType;
(function(ThreadReplySelectType2) {
  ThreadReplySelectType2["PARENT"] = "PARENT";
  ThreadReplySelectType2["THREAD"] = "THREAD";
})(ThreadReplySelectType || (ThreadReplySelectType = {}));

// node_modules/@sendbird/uikit-react/utils-aa4086dc.js
var scrollToRenderedMessage = function(scrollRef, initialTimeStamp, setIsScrolled) {
  var _a;
  try {
    var container = scrollRef.current;
    var element = (_a = container.querySelectorAll('[data-sb-created-at="'.concat(initialTimeStamp, '"]'))) === null || _a === void 0 ? void 0 : _a[0];
    if (element instanceof HTMLElement) {
      var containerHeight = container.offsetHeight;
      var elementHeight = element.offsetHeight;
      var elementOffset = (containerHeight - elementHeight) / 2;
      container.scrollTop = element.offsetTop - elementOffset;
    }
  } catch (_b) {
  } finally {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  }
};
var scrollIntoLast = function(initialTry, scrollRef, setIsScrolled) {
  if (initialTry === void 0) {
    initialTry = 0;
  }
  var MAX_TRIES = 10;
  var currentTry = initialTry;
  if (currentTry > MAX_TRIES) {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
    return;
  }
  try {
    var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector(".sendbird-conversation__messages-padding");
    scrollDOM.scrollTop = scrollDOM.scrollHeight;
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  } catch (error) {
    setTimeout(function() {
      scrollIntoLast(currentTry + 1, scrollRef, setIsScrolled);
    }, 500 * currentTry);
  }
};
var isOperator = function(groupChannel) {
  var myRole = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myRole;
  return myRole === "operator";
};
var isDisabledBecauseFrozen = function(groupChannel) {
  var isFrozen = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen;
  return isFrozen && !isOperator(groupChannel);
};
var isDisabledBecauseMuted = function(groupChannel) {
  var myMutedState = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myMutedState;
  return myMutedState === "muted";
};
var getAllEmojisMapFromEmojiContainer = function(emojiContainer) {
  var _a = emojiContainer.emojiCategories, emojiCategories = _a === void 0 ? [] : _a;
  var allEmojisMap = /* @__PURE__ */ new Map();
  for (var categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {
    var emojis = emojiCategories[categoryIndex].emojis;
    for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {
      var _b = emojis[emojiIndex], key = _b.key, url = _b.url;
      allEmojisMap.set(key, url);
    }
  }
  return allEmojisMap;
};
var getNicknamesMapFromMembers = function(members) {
  if (members === void 0) {
    members = [];
  }
  var nicknamesMap = /* @__PURE__ */ new Map();
  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {
    var _a = members[memberIndex], userId = _a.userId, nickname = _a.nickname;
    nicknamesMap.set(userId, nickname);
  }
  return nicknamesMap;
};
var getUniqueListBy = function(arr, key) {
  var entries = arr.map(function(item) {
    return [item[key], item];
  });
  return Array.from(new Map(entries).values());
};
var getUniqueListByMessageId = function(arr) {
  return getUniqueListBy(arr, "messageId");
};
var sortByCreatedAt = function(messages) {
  return messages.sort(function(a3, b2) {
    return a3.createdAt - b2.createdAt;
  });
};
var mergeAndSortMessages = function(oldMessages, newMessages) {
  var lastOldMessage = oldMessages[oldMessages.length - 1];
  var firstNewMessage = newMessages[0];
  if ((lastOldMessage === null || lastOldMessage === void 0 ? void 0 : lastOldMessage.createdAt) < (firstNewMessage === null || firstNewMessage === void 0 ? void 0 : firstNewMessage.createdAt)) {
    return __spreadArray(__spreadArray([], oldMessages, true), newMessages, true);
  }
  var mergedMessages = __spreadArray(__spreadArray([], oldMessages, true), newMessages, true);
  var unique = getUniqueListByMessageId(mergedMessages);
  return sortByCreatedAt(unique);
};
var getMessageCreatedAt = function(message) {
  return format(message.createdAt, "p");
};
var isSameGroup = function(message, comparingMessage, currentChannel) {
  var _a, _b;
  if (!(message && comparingMessage && message.messageType && message.messageType !== "admin" && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== "admin" && "sender" in message && "sender" in comparingMessage && message.createdAt && comparingMessage.createdAt && message.sender.userId && comparingMessage.sender.userId)) {
    return false;
  }
  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _b === void 0 ? void 0 : _b.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage);
};
var passUnsuccessfullMessages = function(allMessages, newMessage) {
  if ("sendingStatus" in newMessage && (newMessage.sendingStatus === W.SUCCEEDED || newMessage.sendingStatus === W.PENDING)) {
    var lastIndexOfSucceededMessage = allMessages.map(function(message) {
      if ("sendingStatus" in message && message.sendingStatus)
        return message.sendingStatus;
      return message.isAdminMessage() ? W.SUCCEEDED : null;
    }).lastIndexOf(W.SUCCEEDED);
    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {
      var messages = __spreadArray([], allMessages, true);
      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);
      return messages;
    }
  }
  return __spreadArray(__spreadArray([], allMessages, true), [newMessage], false);
};
var pxToNumber2 = function(px) {
  if (typeof px === "number") {
    return px;
  }
  if (typeof px === "string") {
    var parsed = Number.parseFloat(px);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
};
var isAboutSame = function(a3, b2, px) {
  return Math.abs(a3 - b2) <= px;
};

// node_modules/@sendbird/uikit-react/useSendMultipleFilesMessage-b8256698.js
var import_react14 = __toESM(require_react(), 1);
var RESET_MESSAGES = "RESET_MESSAGES";
var FETCH_INITIAL_MESSAGES_START = "FETCH_INITIAL_MESSAGES_START";
var FETCH_INITIAL_MESSAGES_SUCCESS = "FETCH_INITIAL_MESSAGES_SUCCESS";
var FETCH_INITIAL_MESSAGES_FAILURE = "FETCH_INITIAL_MESSAGES_FAILURE";
var FETCH_PREV_MESSAGES_SUCCESS = "FETCH_PREV_MESSAGES_SUCCESS";
var FETCH_PREV_MESSAGES_FAILURE = "FETCH_PREV_MESSAGES_FAILURE";
var FETCH_NEXT_MESSAGES_SUCCESS = "FETCH_NEXT_MESSAGES_SUCCESS";
var FETCH_NEXT_MESSAGES_FAILURE = "FETCH_NEXT_MESSAGES_FAILURE";
var SEND_MESSAGE_START = "SEND_MESSAGE_START";
var SEND_MESSAGE_SUCCESS = "SEND_MESSAGE_SUCCESS";
var SEND_MESSAGE_FAILURE = "SEND_MESSAGE_FAILURE";
var RESEND_MESSAGE_START = "RESEND_MESSAGE_START";
var ON_MESSAGE_RECEIVED = "ON_MESSAGE_RECEIVED";
var ON_MESSAGE_UPDATED = "ON_MESSAGE_UPDATED";
var ON_MESSAGE_THREAD_INFO_UPDATED = "ON_MESSAGE_THREAD_INFO_UPDATED";
var ON_MESSAGE_DELETED = "ON_MESSAGE_DELETED";
var ON_MESSAGE_DELETED_BY_REQ_ID = "ON_MESSAGE_DELETED_BY_REQ_ID";
var SET_CURRENT_CHANNEL = "SET_CURRENT_CHANNEL";
var SET_CHANNEL_INVALID = "SET_CHANNEL_INVALID";
var MARK_AS_READ = "MARK_AS_READ";
var ON_REACTION_UPDATED = "ON_REACTION_UPDATED";
var SET_EMOJI_CONTAINER = "SET_EMOJI_CONTAINER";
var MESSAGE_LIST_PARAMS_CHANGED = "MESSAGE_LIST_PARAMS_CHANGED";
var ON_FILE_INFO_UPLOADED = "ON_FILE_INFO_UPLOADED";
var channelActions = Object.freeze({
  __proto__: null,
  RESET_MESSAGES,
  FETCH_INITIAL_MESSAGES_START,
  FETCH_INITIAL_MESSAGES_SUCCESS,
  FETCH_INITIAL_MESSAGES_FAILURE,
  FETCH_PREV_MESSAGES_SUCCESS,
  FETCH_PREV_MESSAGES_FAILURE,
  FETCH_NEXT_MESSAGES_SUCCESS,
  FETCH_NEXT_MESSAGES_FAILURE,
  SEND_MESSAGE_START,
  SEND_MESSAGE_SUCCESS,
  SEND_MESSAGE_FAILURE,
  RESEND_MESSAGE_START,
  ON_MESSAGE_RECEIVED,
  ON_MESSAGE_UPDATED,
  ON_MESSAGE_THREAD_INFO_UPDATED,
  ON_MESSAGE_DELETED,
  ON_MESSAGE_DELETED_BY_REQ_ID,
  SET_CURRENT_CHANNEL,
  SET_CHANNEL_INVALID,
  MARK_AS_READ,
  ON_REACTION_UPDATED,
  SET_EMOJI_CONTAINER,
  MESSAGE_LIST_PARAMS_CHANGED,
  ON_FILE_INFO_UPLOADED
});
var PublishingModuleType;
(function(PublishingModuleType2) {
  PublishingModuleType2["CHANNEL"] = "CHANNEL";
  PublishingModuleType2["THREAD"] = "THREAD";
})(PublishingModuleType || (PublishingModuleType = {}));
var scrollIntoLast2 = function(intialTry) {
  if (intialTry === void 0) {
    intialTry = 0;
  }
  var MAX_TRIES = 10;
  var currentTry = intialTry;
  if (currentTry > MAX_TRIES) {
    return;
  }
  try {
    var scrollDOM = document.querySelector(".sendbird-thread-ui--scroll");
    scrollDOM.scrollTop = scrollDOM.scrollHeight;
  } catch (error) {
    setTimeout(function() {
      scrollIntoLast2(currentTry + 1);
    }, 500 * currentTry);
  }
};
var useSendMultipleFilesMessage = function(_a, _b) {
  var currentChannel = _a.currentChannel, onBeforeSendMultipleFilesMessage = _a.onBeforeSendMultipleFilesMessage, publishingModules = _a.publishingModules;
  var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef;
  var sendMessage = (0, import_react14.useCallback)(function(files, quoteMessage) {
    return new Promise(function(resolve, reject) {
      if (!currentChannel) {
        logger.warning("Channel: Sending MFm failed, because currentChannel is null.", {
          currentChannel
        });
        reject();
      }
      if (files.length <= 1) {
        logger.warning("Channel: Sending MFM failed, because there are no multiple files.", {
          files
        });
        reject();
      }
      var messageParams = {
        fileInfoList: files.map(function(file) {
          return {
            file,
            fileName: file.name,
            fileSize: file.size,
            mimeType: file.type
          };
        })
      };
      if (quoteMessage) {
        messageParams.isReplyToChannel = true;
        messageParams.parentMessageId = quoteMessage.messageId;
      }
      if (typeof onBeforeSendMultipleFilesMessage === "function") {
        messageParams = onBeforeSendMultipleFilesMessage(files, quoteMessage);
      }
      logger.info("Channel: Start sending MFM", {
        messageParams
      });
      try {
        currentChannel.sendMultipleFilesMessage(messageParams).onFileUploaded(function(requestId, index, uploadableFileInfo, error) {
          logger.info("Channel: onFileUploaded during sending MFM", {
            requestId,
            index,
            error,
            uploadableFileInfo
          });
          pubSub.publish(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, {
            response: {
              channelUrl: currentChannel.url,
              requestId,
              index,
              uploadableFileInfo,
              error
            },
            publishingModules
          });
        }).onPending(function(pendingMessage) {
          logger.info("Channel: in progress of sending MFM", {
            pendingMessage,
            fileInfoList: messageParams.fileInfoList
          });
          pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {
            message: pendingMessage,
            channel: currentChannel,
            publishingModules
          });
          setTimeout(function() {
            if (scrollRef && publishingModules.includes(PublishingModuleType.CHANNEL)) {
              scrollIntoLast(0, scrollRef);
            }
            if (publishingModules.includes(PublishingModuleType.THREAD)) {
              scrollIntoLast2(0);
            }
          }, 100);
        }).onFailed(function(error, failedMessage) {
          logger.error("Channel: Sending MFM failed.", {
            error,
            failedMessage
          });
          pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, {
            channel: currentChannel,
            message: failedMessage,
            publishingModules
          });
          reject(error);
        }).onSucceeded(function(succeededMessage) {
          logger.info("Channel: Sending voice message success!", {
            succeededMessage
          });
          pubSub.publish(PUBSUB_TOPICS.SEND_FILE_MESSAGE, {
            channel: currentChannel,
            message: succeededMessage,
            publishingModules
          });
          setTimeout(function() {
            if (scrollRef && publishingModules.includes(PublishingModuleType.CHANNEL)) {
              scrollIntoLast(0, scrollRef);
            }
            if (publishingModules.includes(PublishingModuleType.THREAD)) {
              scrollIntoLast2(0);
            }
          }, 100);
          resolve(succeededMessage);
        });
      } catch (error) {
        logger.error("Channel: Sending MFM failed.", {
          error
        });
        reject(error);
      }
    });
  }, [currentChannel, onBeforeSendMultipleFilesMessage, publishingModules]);
  return [sendMessage];
};

// node_modules/@sendbird/uikit-react/compareIds-7e517404.js
var isEmpty = function(val) {
  return val === null || val === void 0;
};
function compareIds(a3, b2) {
  if (isEmpty(a3) || isEmpty(b2)) {
    return false;
  }
  var aString = a3.toString();
  var bString = b2.toString();
  return aString === bString;
}

// node_modules/@sendbird/uikit-react/ChannelProvider-9ba5893a.js
var import_react15 = __toESM(require_react(), 1);
function getIsReactionEnabled(_a) {
  var _b = _a.isBroadcast, isBroadcast = _b === void 0 ? false : _b, _c = _a.isSuper, isSuper = _c === void 0 ? false : _c, _d = _a.globalLevel, globalLevel = _d === void 0 ? true : _d, moduleLevel = _a.moduleLevel;
  return !(isBroadcast || isSuper) && (moduleLevel !== null && moduleLevel !== void 0 ? moduleLevel : globalLevel);
}
var initialState = {
  initialized: false,
  loading: true,
  allMessages: [],
  /**
   * localMessages: pending & failed messages
   */
  localMessages: [],
  currentGroupChannel: null,
  // for scrollup
  hasMorePrev: false,
  oldestMessageTimeStamp: 0,
  // for scroll down
  // onScrollDownCallback is added for navigation to different timestamps on messageSearch
  // hasMorePrev, onScrollCallback -> scroll up(default behavior)
  // hasMoreNext, onScrollDownCallback -> scroll down
  hasMoreNext: false,
  latestMessageTimeStamp: 0,
  emojiContainer: {
    emojiCategories: [],
    emojiHash: ""
  },
  unreadSince: null,
  /**
   * unreadSince is a formatted date information string
   * It's used only for the {unreadSince && <UnreadCount time={unreadSince} />}
   */
  isInvalid: false,
  readStatus: null,
  messageListParams: null
};
var getOldestMessageTimeStamp = function(messages) {
  if (messages === void 0) {
    messages = [];
  }
  var oldestMessage = messages[0];
  return oldestMessage && oldestMessage.createdAt || null;
};
var getLatestMessageTimeStamp = function(messages) {
  if (messages === void 0) {
    messages = [];
  }
  var latestMessage = messages[messages.length - 1];
  return latestMessage && latestMessage.createdAt || null;
};
function hasReqId(message) {
  return "reqId" in message;
}
function channelReducer(state, action) {
  return K2(action).with({
    type: RESET_MESSAGES
  }, function() {
    return __assign(__assign({}, state), {
      // when user switches channel, if the previous channel `hasMorePrev`
      // the onScroll gets called twice, setting hasMorePrev false prevents this
      hasMorePrev: false,
      hasMoreNext: false,
      allMessages: []
    });
  }).with({
    type: FETCH_INITIAL_MESSAGES_START
  }, function() {
    return __assign(__assign({}, state), {
      loading: true,
      allMessages: state.allMessages.filter(function(m3) {
        return isSendableMessage(m3) ? m3.sendingStatus !== W.SUCCEEDED : true;
      })
    });
  }).with({
    type: FETCH_INITIAL_MESSAGES_SUCCESS
  }, function(action2) {
    var _a;
    var _b = action2.payload, currentGroupChannel = _b.currentGroupChannel, messages = _b.messages;
    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {
      return state;
    }
    var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);
    var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);
    return __assign(__assign({}, state), {
      loading: false,
      initialized: true,
      hasMorePrev: true,
      hasMoreNext: true,
      oldestMessageTimeStamp,
      latestMessageTimeStamp,
      allMessages: __spreadArray([], messages, true)
    });
  }).with({
    type: FETCH_PREV_MESSAGES_SUCCESS
  }, function(action2) {
    var _a, _b, _c, _d;
    var _e = action2.payload, currentGroupChannel = _e.currentGroupChannel, messages = _e.messages;
    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {
      return state;
    }
    var hasMorePrev = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0) >= ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.prevResultSize) !== null && _d !== void 0 ? _d : PREV_RESULT_SIZE) + 1;
    var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);
    var duplicatedMessageIds = [];
    var updatedOldMessages = state.allMessages.map(function(msg) {
      var duplicatedMessage = messages.find(function(_a2) {
        var messageId = _a2.messageId;
        return compareIds(messageId, msg.messageId);
      });
      if (!duplicatedMessage) {
        return msg;
      }
      duplicatedMessageIds.push(duplicatedMessage.messageId);
      return duplicatedMessage.updatedAt > msg.updatedAt ? duplicatedMessage : msg;
    });
    var filteredNewMessages = duplicatedMessageIds.length > 0 ? messages.filter(function(msg) {
      return !duplicatedMessageIds.find(function(messageId) {
        return compareIds(messageId, msg.messageId);
      });
    }) : messages;
    return __assign(__assign({}, state), {
      hasMorePrev,
      oldestMessageTimeStamp,
      allMessages: __spreadArray(__spreadArray([], filteredNewMessages, true), updatedOldMessages, true)
    });
  }).with({
    type: FETCH_NEXT_MESSAGES_SUCCESS
  }, function(action2) {
    var _a, _b, _c, _d;
    var _e = action2.payload, currentGroupChannel = _e.currentGroupChannel, messages = _e.messages;
    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {
      return state;
    }
    var hasMoreNext = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0) === ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.nextResultSize) !== null && _d !== void 0 ? _d : NEXT_RESULT_SIZE) + 1;
    var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);
    var sortedMessages = mergeAndSortMessages(state.allMessages, messages);
    return __assign(__assign({}, state), {
      hasMoreNext,
      latestMessageTimeStamp,
      allMessages: sortedMessages
    });
  }).with({
    type: S.union(FETCH_INITIAL_MESSAGES_FAILURE, FETCH_PREV_MESSAGES_FAILURE, FETCH_NEXT_MESSAGES_FAILURE)
  }, function(action2) {
    var _a;
    var currentGroupChannel = action2.payload.currentGroupChannel;
    if ((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {
      return state;
    }
    return __assign(__assign({}, state), {
      loading: false,
      initialized: false,
      allMessages: [],
      hasMorePrev: false,
      hasMoreNext: false,
      oldestMessageTimeStamp: null,
      latestMessageTimeStamp: null
    });
  }).with({
    type: SEND_MESSAGE_START
  }, function(action2) {
    return __assign(__assign({}, state), {
      localMessages: __spreadArray(__spreadArray([], state.localMessages, true), [action2.payload], false)
    });
  }).with({
    type: SEND_MESSAGE_SUCCESS
  }, function(action2) {
    var message = action2.payload;
    var filteredMessages = state.allMessages.filter(function(m3) {
      return hasReqId(m3) && (m3 === null || m3 === void 0 ? void 0 : m3.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId);
    });
    return __assign(__assign({}, state), {
      allMessages: __spreadArray(__spreadArray([], filteredMessages, true), [message], false),
      localMessages: state.localMessages.filter(function(m3) {
        return hasReqId(m3) && (m3 === null || m3 === void 0 ? void 0 : m3.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId);
      })
    });
  }).with({
    type: SEND_MESSAGE_FAILURE
  }, function(action2) {
    action2.payload.failed = true;
    return __assign(__assign({}, state), {
      localMessages: state.localMessages.map(function(m3) {
        return compareIds(hasReqId(m3) && m3.reqId, action2.payload.reqId) ? action2.payload : m3;
      })
    });
  }).with({
    type: SET_CURRENT_CHANNEL
  }, function(action2) {
    return __assign(__assign({}, state), {
      currentGroupChannel: action2.payload,
      isInvalid: false
    });
  }).with({
    type: SET_CHANNEL_INVALID
  }, function() {
    return __assign(__assign({}, state), {
      currentGroupChannel: null,
      isInvalid: true
    });
  }).with({
    type: ON_MESSAGE_RECEIVED
  }, function(action2) {
    var _a = action2.payload, channel = _a.channel, message = _a.message;
    var members = channel.members;
    var sender = message.sender;
    var currentGroupChannel = state.currentGroupChannel, unreadSince = state.unreadSince;
    var currentGroupChannelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;
    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {
      return state;
    }
    if (state.allMessages.some(function(msg) {
      return msg.messageId === message.messageId;
    })) {
      return state;
    }
    if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {
      return state;
    }
    if (message.isAdminMessage && message.isAdminMessage()) {
      return __assign(__assign({}, state), {
        allMessages: passUnsuccessfullMessages(state.allMessages, message)
      });
    }
    var senderMember = members === null || members === void 0 ? void 0 : members.find(function(m3) {
      return (m3 === null || m3 === void 0 ? void 0 : m3.userId) === (sender === null || sender === void 0 ? void 0 : sender.userId);
    });
    if ((senderMember === null || senderMember === void 0 ? void 0 : senderMember.profileUrl) !== (sender === null || sender === void 0 ? void 0 : sender.profileUrl) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.friendName) !== (sender === null || sender === void 0 ? void 0 : sender.friendName) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.nickname) !== (sender === null || sender === void 0 ? void 0 : sender.nickname)) {
      channel.members = members.map(function(member) {
        if (member.userId === sender.userId) {
          return sender;
        }
        return member;
      });
    }
    return __assign(__assign({}, state), {
      currentGroupChannel: channel,
      unreadSince: (state === null || state === void 0 ? void 0 : state.unreadSince) ? unreadSince : format(/* @__PURE__ */ new Date(), "p MMM dd"),
      allMessages: passUnsuccessfullMessages(state.allMessages, message)
    });
  }).with({
    type: ON_MESSAGE_UPDATED
  }, function(action2) {
    var _a;
    var _b = action2.payload, channel = _b.channel, message = _b.message;
    var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || "";
    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {
      return state;
    }
    if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {
      return __assign(__assign({}, state), {
        allMessages: state.allMessages.filter(function(m3) {
          return !compareIds(m3.messageId, message === null || message === void 0 ? void 0 : message.messageId);
        })
      });
    }
    return __assign(__assign({}, state), {
      allMessages: state.allMessages.map(function(m3) {
        if (compareIds(m3.messageId, message.messageId)) {
          return message;
        }
        if (compareIds(m3.parentMessageId, message.messageId)) {
          m3.parentMessage = message;
        }
        return m3;
      })
    });
  }).with({
    type: ON_MESSAGE_THREAD_INFO_UPDATED
  }, function(action2) {
    var _a;
    var _b = action2.payload, channel = _b.channel, event = _b.event;
    var channelUrl = event.channelUrl, threadInfo = event.threadInfo, targetMessageId = event.targetMessageId;
    var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || "";
    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl) || !compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
      return state;
    }
    return __assign(__assign({}, state), {
      allMessages: state.allMessages.map(function(m3) {
        if (compareIds(m3.messageId, targetMessageId)) {
          m3.threadInfo = threadInfo;
        }
        return m3;
      })
    });
  }).with({
    type: RESEND_MESSAGE_START
  }, function(action2) {
    return __assign(__assign({}, state), {
      allMessages: state.allMessages.map(function(m3) {
        return compareIds(hasReqId(m3) && m3.reqId, action2.payload.reqId) ? action2.payload : m3;
      })
    });
  }).with({
    type: MARK_AS_READ
  }, function(action2) {
    var _a, _b, _c;
    if (((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) !== ((_c = (_b = action2.payload) === null || _b === void 0 ? void 0 : _b.channel) === null || _c === void 0 ? void 0 : _c.url)) {
      return state;
    }
    return __assign(__assign({}, state), {
      unreadSince: null
    });
  }).with({
    type: ON_MESSAGE_DELETED
  }, function(action2) {
    return __assign(__assign({}, state), {
      allMessages: state.allMessages.filter(function(m3) {
        return !compareIds(m3.messageId, action2.payload);
      })
    });
  }).with({
    type: ON_MESSAGE_DELETED_BY_REQ_ID
  }, function(action2) {
    return __assign(__assign({}, state), {
      localMessages: state.localMessages.filter(function(m3) {
        return !compareIds(hasReqId(m3) && m3.reqId, action2.payload);
      })
    });
  }).with({
    type: SET_EMOJI_CONTAINER
  }, function(action2) {
    return __assign(__assign({}, state), {
      emojiContainer: action2.payload
    });
  }).with({
    type: ON_REACTION_UPDATED
  }, function(action2) {
    return __assign(__assign({}, state), {
      allMessages: state.allMessages.map(function(m3) {
        if (compareIds(m3.messageId, action2.payload.messageId)) {
          if (m3.applyReactionEvent && typeof m3.applyReactionEvent === "function") {
            m3.applyReactionEvent(action2.payload);
          }
          return m3;
        }
        return m3;
      })
    });
  }).with({
    type: MESSAGE_LIST_PARAMS_CHANGED
  }, function(action2) {
    return __assign(__assign({}, state), {
      messageListParams: action2.payload
    });
  }).with({
    type: ON_FILE_INFO_UPLOADED
  }, function(action2) {
    var _a, _b;
    var _c = action2.payload, channelUrl = _c.channelUrl, requestId = _c.requestId, index = _c.index, uploadableFileInfo = _c.uploadableFileInfo, error = _c.error;
    if (!compareIds(channelUrl, (_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {
      return state;
    }
    if (error)
      return state;
    var localMessages = state.localMessages;
    var messageToUpdate = localMessages.find(function(message) {
      return compareIds(hasReqId(message) && message.reqId, requestId);
    });
    var fileInfoList = (_b = messageToUpdate.messageParams) === null || _b === void 0 ? void 0 : _b.fileInfoList;
    if (Array.isArray(fileInfoList)) {
      fileInfoList[index] = uploadableFileInfo;
    }
    return __assign(__assign({}, state), {
      localMessages
    });
  }).otherwise(function() {
    return state;
  });
}
var DELIVERY_RECIPT = "delivery_receipt";
function useHandleChannelEvents(_a, _b) {
  var _c, _d, _e;
  var sdkInit = _a.sdkInit, currentUserId = _a.currentUserId, currentGroupChannel = _a.currentGroupChannel, disableMarkAsRead = _a.disableMarkAsRead;
  var sdk = _b.sdk, logger = _b.logger, scrollRef = _b.scrollRef, setQuoteMessage = _b.setQuoteMessage, messagesDispatcher = _b.messagesDispatcher;
  var store = useSendbirdStateContext();
  var _f = store.config, markAsReadScheduler = _f.markAsReadScheduler, markAsDeliveredScheduler = _f.markAsDeliveredScheduler, disableMarkAsDelivered = _f.disableMarkAsDelivered;
  var canSetMarkAsDelivered = (_e = (_d = (_c = store.stores.sdkStore.sdk) === null || _c === void 0 ? void 0 : _c.appInfo) === null || _d === void 0 ? void 0 : _d.premiumFeatureList) === null || _e === void 0 ? void 0 : _e.find(function(feature) {
    return feature === DELIVERY_RECIPT;
  });
  (0, import_react15.useEffect)(function() {
    var _a2;
    var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;
    var channelHandlerId = uuidv4();
    if (channelUrl && sdkInit) {
      var channelHandler = {
        onMessageReceived: function(channel, message) {
          var _a3, _b2;
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            var scrollToEnd = false;
            try {
              var current = scrollRef.current;
              scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight - 10;
            } catch (error) {
            }
            logger.info("Channel | useHandleChannelEvents: onMessageReceived", message);
            messagesDispatcher({
              type: ON_MESSAGE_RECEIVED,
              payload: {
                channel,
                message
              }
            });
            if (scrollToEnd && ((_a3 = document.getElementById("sendbird-dropdown-portal")) === null || _a3 === void 0 ? void 0 : _a3.childElementCount) === 0 && ((_b2 = document.getElementById("sendbird-emoji-list-portal")) === null || _b2 === void 0 ? void 0 : _b2.childElementCount) === 0) {
              try {
                setTimeout(function() {
                  scrollIntoLast(0, scrollRef);
                });
                if (!disableMarkAsRead) {
                  markAsReadScheduler.push(currentGroupChannel);
                }
                if (canSetMarkAsDelivered && !disableMarkAsDelivered) {
                  markAsDeliveredScheduler.push(currentGroupChannel);
                }
              } catch (error) {
                logger.warning("Channel | onMessageReceived | scroll to end failed");
              }
            }
          }
        },
        onUnreadMemberStatusUpdated: function(channel) {
          logger.info("Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated", channel);
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        // before(onDeliveryReceiptUpdated)
        onUndeliveredMemberStatusUpdated: function(channel) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onDeliveryReceiptUpdated", channel);
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onMessageUpdated: function(channel, message) {
          logger.info("Channel | useHandleChannelEvents: onMessageUpdated", message);
          messagesDispatcher({
            type: ON_MESSAGE_UPDATED,
            payload: {
              channel,
              message
            }
          });
        },
        onThreadInfoUpdated: function(channel, threadInfoUpdateEvent) {
          logger.info("Channel | useHandleChannelEvents: onThreadInfoUpdated", {
            channel,
            threadInfoUpdateEvent
          });
          messagesDispatcher({
            type: ON_MESSAGE_THREAD_INFO_UPDATED,
            payload: {
              channel,
              event: threadInfoUpdateEvent
            }
          });
        },
        onMessageDeleted: function(channel, messageId) {
          logger.info("Channel | useHandleChannelEvents: onMessageDeleted", {
            channel,
            messageId
          });
          setQuoteMessage(null);
          messagesDispatcher({
            type: ON_MESSAGE_DELETED,
            payload: messageId
          });
        },
        onReactionUpdated: function(channel, reactionEvent) {
          logger.info("Channel | useHandleChannelEvents: onReactionUpdated", {
            channel,
            reactionEvent
          });
          messagesDispatcher({
            type: ON_REACTION_UPDATED,
            payload: reactionEvent
          });
        },
        onChannelChanged: function(channel) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onChannelChanged", channel);
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onChannelFrozen: function(channel) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onChannelFrozen", channel);
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onChannelUnfrozen: function(channel) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onChannelUnFrozen", channel);
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onUserMuted: function(channel, user) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onUserMuted", {
              channel,
              user
            });
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onUserUnmuted: function(channel, user) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onUserUnmuted", {
              channel,
              user
            });
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onUserBanned: function(channel, user) {
          var _a3;
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl) && (user === null || user === void 0 ? void 0 : user.userId) === ((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a3 === void 0 ? void 0 : _a3.userId)) {
            logger.info("Channel | useHandleChannelEvents: onUserBanned", {
              channel,
              user
            });
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: null
            });
          }
        },
        onOperatorUpdated: function(channel, users) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onOperatorUpdated", {
              channel,
              users
            });
            messagesDispatcher({
              type: SET_CURRENT_CHANNEL,
              payload: channel
            });
          }
        },
        onUserLeft: function(channel, user) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {
            logger.info("Channel | useHandleChannelEvents: onUserLeft", {
              channel,
              user
            });
            if ((user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
              messagesDispatcher({
                type: SET_CURRENT_CHANNEL,
                payload: null
              });
            }
          }
        }
      };
      logger.info("Channel | useHandleChannelEvents: Setup event handler", {
        channelHandlerId,
        channelHandler
      });
      (_a2 = sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.addGroupChannelHandler(channelHandlerId, new qe(channelHandler));
    }
    return function() {
      var _a3;
      if ((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler) {
        logger.info("Channel | useHandleChannelEvents: Removing message reciver handler", channelHandlerId);
        sdk.groupChannel.removeGroupChannelHandler(channelHandlerId);
      } else if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {
        logger.error("Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler");
      }
    };
  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, sdkInit]);
}
function useSetChannel(_ref, _ref2) {
  let {
    channelUrl,
    sdkInit,
    disableMarkAsRead
  } = _ref;
  let {
    messagesDispatcher,
    sdk,
    logger,
    markAsReadScheduler
  } = _ref2;
  (0, import_react15.useEffect)(() => {
    if (channelUrl && sdkInit && sdk && sdk.groupChannel) {
      logger.info("Channel | useSetChannel fetching channel", channelUrl);
      sdk.groupChannel.getChannel(channelUrl).then((groupChannel) => {
        logger.info("Channel | useSetChannel fetched channel", groupChannel);
        messagesDispatcher({
          type: SET_CURRENT_CHANNEL,
          payload: groupChannel
        });
        logger.info("Channel: Mark as read", groupChannel);
        if (!disableMarkAsRead) {
          markAsReadScheduler.push(groupChannel);
        }
      }).catch((e2) => {
        logger.warning("Channel | useSetChannel fetch channel failed", {
          channelUrl,
          e: e2
        });
        messagesDispatcher({
          type: SET_CHANNEL_INVALID
        });
      });
      sdk.getAllEmoji().then((emojiContainer_) => {
        logger.info("Channel: Getting emojis success", emojiContainer_);
        messagesDispatcher({
          type: SET_EMOJI_CONTAINER,
          payload: emojiContainer_
        });
      }).catch((err) => {
        logger.error("Channel: Getting emojis failed", err);
      });
    }
  }, [channelUrl, sdkInit]);
}
function useInitialMessagesFetch(_a, _b) {
  var currentGroupChannel = _a.currentGroupChannel, initialTimeStamp = _a.initialTimeStamp, userFilledMessageListQuery = _a.userFilledMessageListQuery, replyType = _a.replyType, setIsScrolled = _a.setIsScrolled;
  var logger = _b.logger, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;
  var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;
  (0, import_react15.useEffect)(function() {
    logger.info("Channel useInitialMessagesFetch: Setup started", currentGroupChannel);
    setIsScrolled(false);
    messagesDispatcher({
      type: RESET_MESSAGES,
      payload: null
    });
    if (currentGroupChannel && (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp)) {
      var messageListParams_1 = {
        prevResultSize: PREV_RESULT_SIZE,
        isInclusive: true,
        includeReactions: true,
        includeMetaArray: true
      };
      if (initialTimeStamp) {
        messageListParams_1.nextResultSize = NEXT_RESULT_SIZE;
      }
      if (replyType === "QUOTE_REPLY" || replyType === "THREAD") {
        messageListParams_1.includeThreadInfo = true;
        messageListParams_1.includeParentMessageInfo = true;
        messageListParams_1.replyType = K.ONLY_REPLY_TO_CHANNEL;
      }
      if (userFilledMessageListQuery) {
        Object.keys(userFilledMessageListQuery).forEach(function(key) {
          messageListParams_1[key] = userFilledMessageListQuery[key];
        });
      }
      if (replyType && (replyType === "QUOTE_REPLY" || replyType === "THREAD") || userFilledMessageListQuery) {
        logger.info("Channel useInitialMessagesFetch: Setup messageListParams", messageListParams_1);
        messagesDispatcher({
          type: MESSAGE_LIST_PARAMS_CHANGED,
          payload: messageListParams_1
        });
      }
      logger.info("Channel: Fetching messages", {
        currentGroupChannel,
        userFilledMessageListQuery
      });
      messagesDispatcher({
        type: FETCH_INITIAL_MESSAGES_START,
        payload: null
      });
      var multipleFilesMessageCount_1 = 0;
      currentGroupChannel.getMessagesByTimestamp(initialTimeStamp || (/* @__PURE__ */ new Date()).getTime(), messageListParams_1).then(function(messages) {
        messagesDispatcher({
          type: FETCH_INITIAL_MESSAGES_SUCCESS,
          payload: {
            currentGroupChannel,
            messages
          }
        });
        multipleFilesMessageCount_1 = messages.filter(function(message) {
          return isMultipleFilesMessage(message);
        }).length;
      }).catch(function(error) {
        logger.error("Channel: Fetching messages failed", error);
        messagesDispatcher({
          type: FETCH_INITIAL_MESSAGES_FAILURE,
          payload: {
            currentGroupChannel
          }
        });
      }).finally(function() {
        if (!initialTimeStamp) {
          setTimeout(
            function() {
              return scrollIntoLast(0, scrollRef, setIsScrolled);
            },
            /**
             * Rendering MFM takes long time so we need this.
             * But later we should find better solution.
             */
            Math.min(multipleFilesMessageCount_1 * 100, 1e3)
          );
        } else {
          setTimeout(function() {
            scrollToRenderedMessage(scrollRef, initialTimeStamp, setIsScrolled);
          }, 500);
        }
      });
    }
  }, [channelUrl, userFilledMessageListQuery, initialTimeStamp]);
}
function useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle) {
  if (reconnectOnIdle === void 0) {
    reconnectOnIdle = true;
  }
  var _a = (0, import_react15.useState)(false), isTabHidden = _a[0], setIsTabHidden = _a[1];
  var wasOffline = !isOnline;
  (0, import_react15.useEffect)(function() {
    var handleVisibilityChange = function() {
      if (reconnectOnIdle) {
        setIsTabHidden(document.hidden);
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return function() {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [reconnectOnIdle, document.hidden]);
  var shouldReconnect = wasOffline && (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) != null && !isTabHidden;
  return {
    shouldReconnect
  };
}
function useHandleReconnect(_a, _b) {
  var isOnline = _a.isOnline, replyType = _a.replyType, disableMarkAsRead = _a.disableMarkAsRead, reconnectOnIdle = _a.reconnectOnIdle;
  var logger = _b.logger, sdk = _b.sdk, scrollRef = _b.scrollRef, currentGroupChannel = _b.currentGroupChannel, messagesDispatcher = _b.messagesDispatcher, markAsReadScheduler = _b.markAsReadScheduler, userFilledMessageListQuery = _b.userFilledMessageListQuery;
  var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;
  (0, import_react15.useEffect)(function() {
    return function() {
      var _a2, _b2;
      if (shouldReconnect) {
        logger.info("Refreshing conversation state");
        var isReactionEnabled = ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a2 === void 0 ? void 0 : _a2.useReaction) || false;
        var messageListParams_1 = {
          prevResultSize: PREV_RESULT_SIZE,
          isInclusive: true,
          includeReactions: isReactionEnabled,
          nextResultSize: NEXT_RESULT_SIZE
        };
        if (replyType && replyType === "QUOTE_REPLY") {
          messageListParams_1.includeThreadInfo = true;
          messageListParams_1.includeParentMessageInfo = true;
          messageListParams_1.replyType = K.ONLY_REPLY_TO_CHANNEL;
        }
        if (userFilledMessageListQuery) {
          Object.keys(userFilledMessageListQuery).forEach(function(key) {
            messageListParams_1[key] = userFilledMessageListQuery[key];
          });
        }
        logger.info("Channel: Fetching messages", {
          currentGroupChannel,
          userFilledMessageListQuery
        });
        messagesDispatcher({
          type: FETCH_INITIAL_MESSAGES_START,
          payload: null
        });
        (_b2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b2 === void 0 ? void 0 : _b2.getChannel(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url).then(function(groupChannel) {
          var lastMessageTime = (/* @__PURE__ */ new Date()).getTime();
          groupChannel.getMessagesByTimestamp(lastMessageTime, messageListParams_1).then(function(messages) {
            messagesDispatcher({
              type: FETCH_INITIAL_MESSAGES_SUCCESS,
              payload: {
                currentGroupChannel,
                messages
              }
            });
            setTimeout(function() {
              return scrollIntoLast(0, scrollRef);
            });
          }).catch(function(error) {
            logger.error("Channel: Fetching messages failed", error);
            messagesDispatcher({
              type: FETCH_INITIAL_MESSAGES_FAILURE,
              payload: {
                currentGroupChannel
              }
            });
          });
          if (!disableMarkAsRead) {
            markAsReadScheduler.push(currentGroupChannel);
          }
        });
      }
    };
  }, [shouldReconnect, replyType]);
}
function useScrollCallback(_a, _b) {
  var currentGroupChannel = _a.currentGroupChannel, oldestMessageTimeStamp = _a.oldestMessageTimeStamp, userFilledMessageListQuery = _a.userFilledMessageListQuery, replyType = _a.replyType;
  var hasMorePrev = _b.hasMorePrev, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, sdk = _b.sdk;
  return (0, import_react15.useCallback)(function() {
    var _a2, _b2;
    if (!hasMorePrev) {
      return;
    }
    var messageListParams = {
      prevResultSize: PREV_RESULT_SIZE,
      isInclusive: true,
      includeMetaArray: true,
      includeReactions: (_b2 = (_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a2 === void 0 ? void 0 : _a2.useReaction) !== null && _b2 !== void 0 ? _b2 : false
    };
    if (replyType === "QUOTE_REPLY" || replyType === "THREAD") {
      messageListParams.includeThreadInfo = true;
      messageListParams.includeParentMessageInfo = true;
      messageListParams.replyType = K.ONLY_REPLY_TO_CHANNEL;
    }
    if (userFilledMessageListQuery) {
      Object.keys(userFilledMessageListQuery).forEach(function(key) {
        messageListParams[key] = userFilledMessageListQuery[key];
      });
    }
    logger.info("Channel: Fetching messages", {
      currentGroupChannel,
      userFilledMessageListQuery
    });
    currentGroupChannel.getMessagesByTimestamp(oldestMessageTimeStamp || (/* @__PURE__ */ new Date()).getTime(), messageListParams).then(function(messages) {
      messagesDispatcher({
        type: FETCH_PREV_MESSAGES_SUCCESS,
        payload: {
          currentGroupChannel,
          messages
        }
      });
    }).catch(function() {
      messagesDispatcher({
        type: FETCH_PREV_MESSAGES_FAILURE,
        payload: {
          currentGroupChannel
        }
      });
    });
  }, [currentGroupChannel, oldestMessageTimeStamp, replyType]);
}
function useScrollDownCallback(_ref, _ref2) {
  let {
    currentGroupChannel,
    latestMessageTimeStamp,
    userFilledMessageListQuery,
    hasMoreNext,
    replyType
  } = _ref;
  let {
    logger,
    messagesDispatcher,
    sdk
  } = _ref2;
  return (0, import_react15.useCallback)((cb) => {
    if (!hasMoreNext) {
      return;
    }
    const {
      appInfo = {}
    } = sdk;
    const isReactionEnabled = appInfo.useReaction || false;
    const messageListParams = {
      nextResultSize: NEXT_RESULT_SIZE,
      isInclusive: true,
      includeReactions: isReactionEnabled
    };
    messageListParams.includeMetaArray = true;
    if (replyType && (replyType === "QUOTE_REPLY" || replyType === "THREAD")) {
      messageListParams.includeThreadInfo = true;
      messageListParams.includeParentMessageInfo = true;
      messageListParams.replyType = K.ONLY_REPLY_TO_CHANNEL;
    }
    if (userFilledMessageListQuery) {
      Object.keys(userFilledMessageListQuery).forEach((key) => {
        messageListParams[key] = userFilledMessageListQuery[key];
      });
    }
    logger.info("Channel: Fetching later messages", {
      currentGroupChannel,
      userFilledMessageListQuery
    });
    currentGroupChannel.getMessagesByTimestamp(latestMessageTimeStamp || (/* @__PURE__ */ new Date()).getTime(), messageListParams).then((messages) => {
      messagesDispatcher({
        type: FETCH_NEXT_MESSAGES_SUCCESS,
        payload: {
          currentGroupChannel,
          messages
        }
      });
      cb([messages, null]);
    }).catch((error) => {
      logger.error("Channel: Fetching later messages failed", error);
      messagesDispatcher({
        type: FETCH_NEXT_MESSAGES_FAILURE,
        payload: {
          currentGroupChannel
        }
      });
      cb([null, error]);
    });
  }, [currentGroupChannel, latestMessageTimeStamp, hasMoreNext, replyType]);
}
function useDeleteMessageCallback(_ref, _ref2) {
  let {
    currentGroupChannel,
    messagesDispatcher
  } = _ref;
  let {
    logger
  } = _ref2;
  return (0, import_react15.useCallback)((message) => {
    logger.info("Channel | useDeleteMessageCallback: Deleting message", message);
    const {
      sendingStatus
    } = message;
    return new Promise((resolve, reject) => {
      logger.info("Channel | useDeleteMessageCallback: Deleting message requestState:", sendingStatus);
      if (sendingStatus === "failed" || sendingStatus === "pending") {
        logger.info("Channel | useDeleteMessageCallback: Deleted message from local:", message);
        messagesDispatcher({
          type: ON_MESSAGE_DELETED_BY_REQ_ID,
          payload: message.reqId
        });
        resolve(message);
      } else {
        logger.info("Channel | useDeleteMessageCallback: Deleting message from remote:", sendingStatus);
        currentGroupChannel.deleteMessage(message).then(() => {
          logger.info("Channel | useDeleteMessageCallback: Deleting message success!", message);
          messagesDispatcher({
            type: ON_MESSAGE_DELETED,
            payload: message.messageId
          });
          resolve(message);
        }).catch((err) => {
          logger.warning("Channel | useDeleteMessageCallback: Deleting message failed!", err);
          reject(err);
        });
      }
    });
  }, [currentGroupChannel, messagesDispatcher]);
}
function useUpdateMessageCallback(_ref, _ref2) {
  let {
    currentGroupChannel,
    messagesDispatcher,
    onBeforeUpdateUserMessage,
    isMentionEnabled
  } = _ref;
  let {
    logger,
    pubSub
  } = _ref2;
  return (0, import_react15.useCallback)((props, callback) => {
    const {
      messageId,
      message,
      mentionedUsers,
      mentionTemplate
    } = props;
    const createParamsDefault = () => {
      const params2 = {};
      params2.message = message;
      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {
        params2.mentionedUsers = mentionedUsers;
      }
      if (isMentionEnabled && mentionTemplate) {
        params2.mentionedMessageTemplate = mentionTemplate;
      } else {
        params2.mentionedMessageTemplate = message;
      }
      return params2;
    };
    const createCustomPrams = onBeforeUpdateUserMessage && typeof onBeforeUpdateUserMessage === "function";
    if (createCustomPrams) {
      logger.info("Channel: creating params using onBeforeUpdateUserMessage", onBeforeUpdateUserMessage);
    }
    const params = onBeforeUpdateUserMessage ? onBeforeUpdateUserMessage(message) : createParamsDefault();
    logger.info("Channel: Updating message!", params);
    currentGroupChannel.updateUserMessage(messageId, params).then((msg, err) => {
      if (callback) {
        callback(err, msg);
      }
      logger.info("Channel: Updating message success!", msg);
      messagesDispatcher({
        type: ON_MESSAGE_UPDATED,
        payload: {
          channel: currentGroupChannel,
          message: msg
        }
      });
      pubSub.publish(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, {
        message: msg,
        channel: currentGroupChannel,
        publishingModules: [PublishingModuleType.CHANNEL]
      });
    });
  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, messagesDispatcher, onBeforeUpdateUserMessage]);
}
function useResendMessageCallback(_ref, _ref2) {
  let {
    currentGroupChannel,
    messagesDispatcher
  } = _ref;
  let {
    logger
  } = _ref2;
  return (0, import_react15.useCallback)((failedMessage) => {
    logger.info("Channel: Resending message has started", failedMessage);
    const {
      messageType,
      file
    } = failedMessage;
    if (failedMessage !== null && failedMessage !== void 0 && failedMessage.isResendable) {
      failedMessage.requestState = "pending";
      failedMessage.sendingStatus = "pending";
      messagesDispatcher({
        type: RESEND_MESSAGE_START,
        payload: failedMessage
      });
      if (messageType === "user") {
        currentGroupChannel.resendUserMessage(failedMessage).then((message) => {
          logger.info("Channel: Resending message success!", message);
          messagesDispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
        }).catch((e2) => {
          logger.warning("Channel: Resending message failed!", e2);
          failedMessage.requestState = "failed";
          failedMessage.sendingStatus = "failed";
          messagesDispatcher({
            type: SEND_MESSAGE_FAILURE,
            payload: failedMessage
          });
        });
        failedMessage.requestState = "pending";
        failedMessage.sendingStatus = "pending";
        messagesDispatcher({
          type: RESEND_MESSAGE_START,
          payload: failedMessage
        });
        return;
      }
      if (messageType === "file") {
        currentGroupChannel.resendFileMessage(failedMessage, file).then((message) => {
          logger.info("Channel: Resending file message success!", message);
          messagesDispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
        }).catch((e2) => {
          logger.warning("Channel: Resending file message failed!", e2);
          failedMessage.requestState = "failed";
          failedMessage.sendingStatus = "failed";
          messagesDispatcher({
            type: SEND_MESSAGE_FAILURE,
            payload: failedMessage
          });
        });
        failedMessage.requestState = "pending";
        failedMessage.sendingStatus = "pending";
        messagesDispatcher({
          type: RESEND_MESSAGE_START,
          payload: failedMessage
        });
      }
      if (isMultipleFilesMessage(failedMessage)) {
        currentGroupChannel.resendMessage(failedMessage).onPending((message) => {
          messagesDispatcher({
            type: RESEND_MESSAGE_START,
            payload: message
          });
        }).onSucceeded((message) => {
          logger.info("Channel: Resending multiple files message success!", message);
          messagesDispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
        }).onFailed((e2, message) => {
          logger.warning("Channel: Resending multiple files message failed!", e2);
          messagesDispatcher({
            type: SEND_MESSAGE_FAILURE,
            payload: message
          });
        });
      }
    } else {
      console.error("Message is not resendable");
      logger.warning("Message is not resendable", failedMessage);
    }
  }, [currentGroupChannel, messagesDispatcher]);
}
function useSendMessageCallback(_ref, _ref2) {
  let {
    isMentionEnabled,
    currentGroupChannel,
    onBeforeSendUserMessage
  } = _ref;
  let {
    logger,
    pubSub,
    scrollRef,
    messagesDispatcher
  } = _ref2;
  const messageInputRef = (0, import_react15.useRef)(null);
  const sendMessage = (0, import_react15.useCallback)((props) => {
    const {
      quoteMessage = null,
      message,
      mentionTemplate,
      // mentionedUserIds,
      mentionedUsers
    } = props;
    const createParamsDefault = () => {
      const params2 = {};
      params2.message = message;
      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {
        params2.mentionedUsers = mentionedUsers;
      }
      if (isMentionEnabled && mentionTemplate && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {
        params2.mentionedMessageTemplate = mentionTemplate;
      }
      if (quoteMessage) {
        params2.isReplyToChannel = true;
        params2.parentMessageId = quoteMessage.messageId;
      }
      return params2;
    };
    const createCustomPrams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === "function";
    if (createCustomPrams) {
      logger.info("Channel: creating params using onBeforeSendUserMessage", onBeforeSendUserMessage);
    }
    const params = onBeforeSendUserMessage ? onBeforeSendUserMessage(message, quoteMessage) : createParamsDefault();
    logger.info("Channel: Sending message has started", params);
    currentGroupChannel.sendUserMessage(params).onPending((pendingMsg) => {
      pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {
        /* pubSub is used instead of messagesDispatcher
          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
        message: pendingMsg,
        channel: currentGroupChannel,
        publishingModules: [PublishingModuleType.CHANNEL]
      });
      setTimeout(() => scrollIntoLast(0, scrollRef));
    }).onFailed((err, msg) => {
      logger.warning("Channel: Sending message failed!", {
        message: msg,
        error: err
      });
      messagesDispatcher({
        type: SEND_MESSAGE_FAILURE,
        payload: msg
      });
    }).onSucceeded((msg) => {
      logger.info("Channel: Sending message success!", msg);
      messagesDispatcher({
        type: SEND_MESSAGE_SUCCESS,
        payload: msg
      });
    });
  }, [currentGroupChannel, onBeforeSendUserMessage]);
  return [messageInputRef, sendMessage];
}
function useSendFileMessageCallback(_ref, _ref2) {
  let {
    currentGroupChannel,
    onBeforeSendFileMessage,
    imageCompression = {}
  } = _ref;
  let {
    logger,
    pubSub,
    scrollRef,
    messagesDispatcher
  } = _ref2;
  const sendMessage = (0, import_react15.useCallback)(function(file) {
    let quoteMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return new Promise((resolve, reject) => {
      const {
        compressionRate,
        resizingWidth,
        resizingHeight
      } = imageCompression;
      const createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === "function";
      const compressibleFileType = file.type === "image/jpg" || file.type === "image/png" || file.type === "image/jpeg";
      const compressibleRatio = compressionRate > 0 && compressionRate < 1;
      const compressibleDiamensions = pxToNumber2(resizingWidth) || pxToNumber2(resizingHeight);
      const canCompressImage = compressibleFileType && (compressibleRatio || compressibleDiamensions);
      const createParamsDefault = (file_) => {
        const params = {};
        params.file = file_;
        if (quoteMessage) {
          params.isReplyToChannel = true;
          params.parentMessageId = quoteMessage.messageId;
        }
        return params;
      };
      if (canCompressImage) {
        try {
          const image = document.createElement("img");
          image.src = URL.createObjectURL(file);
          image.onload = () => {
            URL.revokeObjectURL(image.src);
            const canvas = document.createElement("canvas");
            const imageWdith = image.naturalWidth || image.width;
            const imageHeight = image.naturalHeight || image.height;
            let targetWidth = pxToNumber2(resizingWidth) || imageWdith;
            let targetHeight = pxToNumber2(resizingHeight) || imageHeight;
            if (file.type === "image/png" && !compressibleDiamensions) {
              targetWidth *= compressionRate;
              targetHeight *= compressionRate;
            }
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, targetWidth, targetHeight);
            context.canvas.toBlob((newImageBlob) => {
              const compressedFile = new File([newImageBlob], file.name, {
                type: file.type
              });
              if (createCustomParams) {
                logger.info("Channel: Creating params using onBeforeSendFileMessage", onBeforeSendFileMessage);
              }
              const params = createCustomParams ? onBeforeSendFileMessage(compressedFile, quoteMessage) : createParamsDefault(compressedFile);
              logger.info("Channel: Uploading file message start!", params);
              currentGroupChannel.sendFileMessage(params).onPending((pendingMessage) => {
                pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {
                  /* pubSub is used instead of messagesDispatcher
                      to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
                  message: _objectSpread2(_objectSpread2({}, pendingMessage), {}, {
                    url: URL.createObjectURL(compressedFile),
                    // pending thumbnail message seems to be failed
                    requestState: "pending"
                  }),
                  channel: currentGroupChannel,
                  publishingModules: [PublishingModuleType.CHANNEL]
                });
                setTimeout(() => scrollIntoLast(0, scrollRef), 1e3);
              }).onFailed((err, failedMessage) => {
                logger.error("Channel: Sending file message failed!", {
                  failedMessage,
                  err
                });
                failedMessage.localUrl = URL.createObjectURL(compressedFile);
                failedMessage.file = compressedFile;
                messagesDispatcher({
                  type: SEND_MESSAGE_FAILURE,
                  payload: failedMessage
                });
                reject(err);
              }).onSucceeded((succeededMessage) => {
                logger.info("Channel: Sending file message success!", succeededMessage);
                messagesDispatcher({
                  type: SEND_MESSAGE_SUCCESS,
                  payload: succeededMessage
                });
                resolve(succeededMessage);
              });
            }, file.type, compressionRate);
          };
        } catch (error) {
          logger.error("Channel: Sending file message failed!", error);
          reject(error);
        }
      } else {
        if (createCustomParams) {
          logger.info("Channel: creating params using onBeforeSendFileMessage", onBeforeSendFileMessage);
        }
        const params = onBeforeSendFileMessage ? onBeforeSendFileMessage(file, quoteMessage) : createParamsDefault(file);
        logger.info("Channel: Uploading file message start!", params);
        currentGroupChannel.sendFileMessage(params).onPending((pendingMsg) => {
          pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {
            /* pubSub is used instead of messagesDispatcher
                to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
            message: _objectSpread2(_objectSpread2({}, pendingMsg), {}, {
              url: URL.createObjectURL(file),
              // pending thumbnail message seems to be failed
              requestState: "pending"
            }),
            channel: currentGroupChannel,
            publishingModules: [PublishingModuleType.CHANNEL]
          });
          setTimeout(() => scrollIntoLast(0, scrollRef), 1e3);
        }).onFailed((error, message) => {
          logger.error("Channel: Sending file message failed!", {
            message,
            error
          });
          message.localUrl = URL.createObjectURL(file);
          message.file = file;
          messagesDispatcher({
            type: SEND_MESSAGE_FAILURE,
            payload: message
          });
          reject(error);
        }).onSucceeded((message) => {
          logger.info("Channel: Sending message success!", message);
          messagesDispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
          resolve(message);
        });
      }
    });
  }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);
  return [sendMessage];
}
function useToggleReactionCallback(_ref, _ref2) {
  let {
    currentGroupChannel
  } = _ref;
  let {
    logger
  } = _ref2;
  return (0, import_react15.useCallback)((message, key, isReacted) => {
    if (isReacted) {
      currentGroupChannel.deleteReaction(message, key).then((res) => {
        logger.info("Delete reaction success", res);
      }).catch((err) => {
        logger.warning("Delete reaction failed", err);
      });
      return;
    }
    currentGroupChannel.addReaction(message, key).then((res) => {
      logger.info("Add reaction success", res);
    }).catch((err) => {
      logger.warning("Add reaction failed", err);
    });
  }, [currentGroupChannel]);
}
function deactivateClick(scrollRef) {
  var element = scrollRef.current;
  var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;
  if (element && parentNode) {
    element.style.pointerEvents = "none";
    parentNode.style.cursor = "wait";
  }
}
function activateClick(scrollRef) {
  var element = scrollRef.current;
  var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;
  if (element && parentNode) {
    element.style.pointerEvents = "auto";
    parentNode.style.cursor = "auto";
  }
}
function useScrollToMessage(_a, _b) {
  var setInitialTimeStamp = _a.setInitialTimeStamp, setAnimatedMessageId = _a.setAnimatedMessageId, allMessages = _a.allMessages, scrollRef = _a.scrollRef;
  var logger = _b.logger;
  return (0, import_react15.useCallback)(function(createdAt, messageId) {
    var isPresent = allMessages.find(function(m3) {
      return m3.messageId === messageId;
    });
    setAnimatedMessageId(null);
    setTimeout(function() {
      try {
        logger.info("Channel: scroll to message - disabling mouse events");
        deactivateClick(scrollRef);
        if (isPresent) {
          logger.info("Channel: scroll to message - message is present");
          setAnimatedMessageId(messageId);
          scrollToRenderedMessage(scrollRef, createdAt);
        } else {
          logger.info("Channel: scroll to message - fetching older messages");
          setInitialTimeStamp(null);
          setInitialTimeStamp(createdAt);
          setAnimatedMessageId(messageId);
        }
      } finally {
        logger.info("Channel: scroll to message - enabled mouse events");
        activateClick(scrollRef);
      }
    });
  }, [setInitialTimeStamp, setAnimatedMessageId, allMessages]);
}
var useSendVoiceMessageCallback = function(_a, _b) {
  var currentGroupChannel = _a.currentGroupChannel, onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage;
  var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;
  var sendMessage = (0, import_react15.useCallback)(function(file, duration, quoteMessage) {
    if (!currentGroupChannel) {
      return;
    }
    var messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === "function" ? onBeforeSendVoiceMessage(file, quoteMessage) : {
      file,
      fileName: VOICE_MESSAGE_FILE_NAME,
      mimeType: VOICE_MESSAGE_MIME_TYPE,
      metaArrays: [new xe({
        key: META_ARRAY_VOICE_DURATION_KEY,
        value: ["".concat(duration)]
      }), new xe({
        key: META_ARRAY_MESSAGE_TYPE_KEY,
        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]
      })]
    };
    if (quoteMessage) {
      messageParams.isReplyToChannel = true;
      messageParams.parentMessageId = quoteMessage.messageId;
    }
    logger.info("Channel: Start sending voice message", messageParams);
    currentGroupChannel.sendFileMessage(messageParams).onPending(function(pendingMessage) {
      pubSub.publish(PUBSUB_TOPICS.SEND_MESSAGE_START, {
        /* pubSub is used instead of messagesDispatcher
          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */
        message: pendingMessage,
        channel: currentGroupChannel,
        publishingModules: [PublishingModuleType.CHANNEL]
      });
      setTimeout(function() {
        return scrollIntoLast(0, scrollRef);
      }, 1e3);
    }).onFailed(function(err, failedMessage) {
      logger.error("Channel: Sending voice message failed!", {
        failedMessage,
        err
      });
      messagesDispatcher({
        type: SEND_MESSAGE_FAILURE,
        payload: failedMessage
      });
    }).onSucceeded(function(succeededMessage) {
      logger.info("Channel: Sending voice message success!", succeededMessage);
      messagesDispatcher({
        type: SEND_MESSAGE_SUCCESS,
        payload: succeededMessage
      });
    });
  }, [currentGroupChannel, onBeforeSendVoiceMessage]);
  return [sendMessage];
};
var useHandleChannelPubsubEvents = function(_a) {
  var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, pubSub = _a.pubSub, dispatcher = _a.dispatcher, scrollRef = _a.scrollRef;
  (0, import_react15.useEffect)(function() {
    var subscriber = /* @__PURE__ */ new Map();
    if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {
      subscriber.set(PUBSUB_TOPICS.SEND_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_USER_MESSAGE, function(props) {
        var channel = props.channel, message = props.message;
        scrollIntoLast(0, scrollRef);
        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
          dispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_START, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_START, function(props) {
        var _a2 = props, channel = _a2.channel, message = _a2.message, publishingModules = _a2.publishingModules;
        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && publishingModules.includes(PublishingModuleType.CHANNEL)) {
          dispatcher({
            type: SEND_MESSAGE_START,
            payload: message
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function(props) {
        var _a2 = props, response = _a2.response, publishingModules = _a2.publishingModules;
        if (channelUrl === response.channelUrl && publishingModules.includes(PublishingModuleType.CHANNEL)) {
          dispatcher({
            type: ON_FILE_INFO_UPLOADED,
            payload: response
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, function(props) {
        var _a2 = props, channel = _a2.channel, message = _a2.message, publishingModules = _a2.publishingModules;
        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && publishingModules.includes(PublishingModuleType.CHANNEL)) {
          dispatcher({
            type: SEND_MESSAGE_FAILURE,
            payload: message
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.SEND_FILE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_FILE_MESSAGE, function(props) {
        var channel = props.channel, message = props.message;
        scrollIntoLast(0, scrollRef);
        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
          dispatcher({
            type: SEND_MESSAGE_SUCCESS,
            payload: message
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, function(props) {
        var channel = props.channel, message = props.message, fromSelector = props.fromSelector;
        if (fromSelector && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
          dispatcher({
            type: ON_MESSAGE_UPDATED,
            payload: {
              channel,
              message
            }
          });
        }
      }));
      subscriber.set(PUBSUB_TOPICS.DELETE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.DELETE_MESSAGE, function(props) {
        var channel = props.channel, messageId = props.messageId;
        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
          dispatcher({
            type: ON_MESSAGE_DELETED,
            payload: messageId
          });
        }
      }));
    }
    return function() {
      subscriber.forEach(function(s3) {
        try {
          s3.remove();
        } catch (_a2) {
        }
      });
    };
  }, [channelUrl, sdkInit]);
};
var ChannelContext = import_react15.default.createContext(void 0);
var ChannelProvider = function(props) {
  var _a, _b, _c, _d, _e, _f;
  var channelUrl = props.channelUrl, children = props.children, isReactionEnabled = props.isReactionEnabled, _g = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _g === void 0 ? true : _g, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, showSearchIcon = props.showSearchIcon, animatedMessage = props.animatedMessage, highlightedMessage = props.highlightedMessage, startingPoint = props.startingPoint, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onChatHeaderActionClick = props.onChatHeaderActionClick, onSearchClick = props.onSearchClick, onBackClick = props.onBackClick, channelReplyType = props.replyType, threadReplySelectType = props.threadReplySelectType, queries = props.queries, filterMessageList = props.filterMessageList, _h = props.disableMarkAsRead, disableMarkAsRead = _h === void 0 ? false : _h, onReplyInThread = props.onReplyInThread, onQuoteMessageClick = props.onQuoteMessageClick, onMessageAnimated = props.onMessageAnimated, onMessageHighlighted = props.onMessageHighlighted, _j = props.scrollBehavior, scrollBehavior = _j === void 0 ? "auto" : _j, _k = props.reconnectOnIdle, reconnectOnIdle = _k === void 0 ? true : _k;
  var globalStore = useSendbirdStateContext();
  var config = globalStore.config;
  var replyType = channelReplyType !== null && channelReplyType !== void 0 ? channelReplyType : config.replyType;
  var pubSub = config.pubSub, logger = config.logger, userId = config.userId, isOnline = config.isOnline, imageCompression = config.imageCompression, isMentionEnabled = config.isMentionEnabled, isVoiceMessageEnabled = config.isVoiceMessageEnabled, onUserProfileMessage = config.onUserProfileMessage, markAsReadScheduler = config.markAsReadScheduler, groupChannel = config.groupChannel;
  var sdk = (_b = (_a = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _a === void 0 ? void 0 : _a.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;
  var sdkInit = (_d = (_c = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _c === void 0 ? void 0 : _c.sdkStore) === null || _d === void 0 ? void 0 : _d.initialized;
  var globalConfigs = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config;
  var _l = (0, import_react15.useState)(startingPoint), initialTimeStamp = _l[0], setInitialTimeStamp = _l[1];
  (0, import_react15.useEffect)(function() {
    setInitialTimeStamp(startingPoint);
  }, [startingPoint, channelUrl]);
  var _m = (0, import_react15.useState)(0), animatedMessageId = _m[0], setAnimatedMessageId = _m[1];
  var _o = (0, import_react15.useState)(highlightedMessage), highLightedMessageId = _o[0], setHighLightedMessageId = _o[1];
  (0, import_react15.useEffect)(function() {
    setHighLightedMessageId(highlightedMessage);
  }, [highlightedMessage]);
  var userFilledMessageListQuery = queries === null || queries === void 0 ? void 0 : queries.messageListParams;
  var _p = (0, import_react15.useState)(null), quoteMessage = _p[0], setQuoteMessage = _p[1];
  var _q = (0, import_react15.useState)(false), isScrolled = _q[0], setIsScrolled = _q[1];
  var _r = (0, import_react15.useReducer)(channelReducer, initialState), messagesStore = _r[0], messagesDispatcher = _r[1];
  var scrollRef = (0, import_react15.useRef)(null);
  var allMessages = messagesStore.allMessages, localMessages = messagesStore.localMessages, loading = messagesStore.loading, initialized = messagesStore.initialized, unreadSince = messagesStore.unreadSince, isInvalid = messagesStore.isInvalid, currentGroupChannel = messagesStore.currentGroupChannel, hasMorePrev = messagesStore.hasMorePrev, oldestMessageTimeStamp = messagesStore.oldestMessageTimeStamp, hasMoreNext = messagesStore.hasMoreNext, latestMessageTimeStamp = messagesStore.latestMessageTimeStamp, emojiContainer = messagesStore.emojiContainer, readStatus = messagesStore.readStatus;
  var isSuper = (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.isSuper) || false;
  var isBroadcast = (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.isBroadcast) || false;
  var usingReaction = getIsReactionEnabled({
    isBroadcast,
    isSuper,
    globalLevel: config === null || config === void 0 ? void 0 : config.isReactionEnabled,
    moduleLevel: isReactionEnabled
  });
  var emojiAllMap = (0, import_react15.useMemo)(function() {
    return usingReaction ? getAllEmojisMapFromEmojiContainer(emojiContainer) : /* @__PURE__ */ new Map();
  }, [emojiContainer]);
  var nicknamesMap = (0, import_react15.useMemo)(function() {
    return usingReaction && currentGroupChannel ? getNicknamesMapFromMembers(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members) : /* @__PURE__ */ new Map();
  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members]);
  (0, import_react15.useEffect)(function() {
    if (animatedMessage) {
      setAnimatedMessageId(animatedMessage);
    }
  }, [animatedMessage]);
  var onScrollCallback = useScrollCallback({
    currentGroupChannel,
    oldestMessageTimeStamp,
    userFilledMessageListQuery,
    replyType
  }, {
    hasMorePrev,
    logger,
    messagesDispatcher,
    sdk
  });
  var scrollToMessage = useScrollToMessage({
    setInitialTimeStamp,
    setAnimatedMessageId,
    allMessages,
    scrollRef
  }, {
    logger
  });
  var onScrollDownCallback = useScrollDownCallback({
    currentGroupChannel,
    latestMessageTimeStamp,
    userFilledMessageListQuery,
    hasMoreNext,
    replyType,
    isVoiceMessageEnabled
  }, {
    logger,
    messagesDispatcher,
    sdk
  });
  var toggleReaction = useToggleReactionCallback({
    currentGroupChannel
  }, {
    logger
  });
  useSetChannel({
    channelUrl,
    sdkInit,
    disableMarkAsRead
  }, {
    messagesDispatcher,
    sdk,
    logger,
    markAsReadScheduler
  });
  (0, import_react15.useEffect)(function() {
    setQuoteMessage(null);
  }, [channelUrl]);
  useHandleChannelEvents({
    currentGroupChannel,
    sdkInit,
    currentUserId: userId,
    disableMarkAsRead
  }, {
    messagesDispatcher,
    sdk,
    logger,
    scrollRef,
    setQuoteMessage
  });
  useInitialMessagesFetch({
    currentGroupChannel,
    userFilledMessageListQuery,
    initialTimeStamp,
    replyType,
    setIsScrolled
  }, {
    logger,
    scrollRef,
    messagesDispatcher
  });
  useHandleChannelPubsubEvents({
    channelUrl,
    sdkInit,
    pubSub,
    dispatcher: messagesDispatcher,
    scrollRef
  });
  useHandleReconnect({
    isOnline,
    replyType,
    disableMarkAsRead,
    reconnectOnIdle
  }, {
    logger,
    sdk,
    scrollRef,
    currentGroupChannel,
    messagesDispatcher,
    userFilledMessageListQuery,
    markAsReadScheduler
  });
  var deleteMessage = useDeleteMessageCallback({
    currentGroupChannel,
    messagesDispatcher
  }, {
    logger
  });
  var updateMessage = useUpdateMessageCallback({
    currentGroupChannel,
    messagesDispatcher,
    onBeforeUpdateUserMessage,
    isMentionEnabled
  }, {
    logger,
    pubSub
  });
  var resendMessage = useResendMessageCallback({
    currentGroupChannel,
    messagesDispatcher
  }, {
    logger
  });
  var _s2 = useSendMessageCallback({
    currentGroupChannel,
    isMentionEnabled,
    onBeforeSendUserMessage
  }, {
    logger,
    pubSub,
    scrollRef,
    messagesDispatcher
  }), messageInputRef = _s2[0], sendMessage = _s2[1];
  var sendFileMessage = useSendFileMessageCallback({
    currentGroupChannel,
    imageCompression,
    onBeforeSendFileMessage
  }, {
    logger,
    pubSub,
    scrollRef,
    messagesDispatcher
  })[0];
  var sendVoiceMessage = useSendVoiceMessageCallback({
    currentGroupChannel,
    onBeforeSendVoiceMessage
  }, {
    logger,
    pubSub,
    scrollRef,
    messagesDispatcher
  })[0];
  var sendMultipleFilesMessage = useSendMultipleFilesMessage({
    currentChannel: currentGroupChannel,
    onBeforeSendMultipleFilesMessage,
    publishingModules: [PublishingModuleType.CHANNEL]
  }, {
    logger,
    pubSub,
    scrollRef
  })[0];
  return import_react15.default.createElement(ChannelContext.Provider, {
    value: {
      // props
      channelUrl,
      isReactionEnabled: usingReaction,
      isMessageGroupingEnabled,
      isMultipleFilesMessageEnabled,
      showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : globalConfigs.showSearchIcon,
      highlightedMessage,
      startingPoint,
      onBeforeSendUserMessage,
      onBeforeSendFileMessage,
      onBeforeUpdateUserMessage,
      onChatHeaderActionClick,
      onSearchClick,
      onBackClick,
      replyType,
      threadReplySelectType: (_e = threadReplySelectType !== null && threadReplySelectType !== void 0 ? threadReplySelectType : getCaseResolvedThreadReplySelectType(groupChannel.threadReplySelectType).upperCase) !== null && _e !== void 0 ? _e : ThreadReplySelectType.THREAD,
      queries,
      filterMessageList,
      disableMarkAsRead,
      onReplyInThread,
      onQuoteMessageClick,
      onMessageAnimated,
      onMessageHighlighted,
      // messagesStore
      allMessages,
      localMessages,
      loading,
      initialized,
      unreadSince,
      isInvalid,
      currentGroupChannel,
      hasMorePrev,
      hasMoreNext,
      oldestMessageTimeStamp,
      latestMessageTimeStamp,
      emojiContainer,
      readStatus,
      // utils
      scrollToMessage,
      quoteMessage,
      setQuoteMessage,
      deleteMessage,
      updateMessage,
      resendMessage,
      messageInputRef,
      sendMessage,
      sendFileMessage,
      sendVoiceMessage,
      sendMultipleFilesMessage,
      initialTimeStamp,
      messageActionTypes: channelActions,
      messagesDispatcher,
      setInitialTimeStamp,
      setAnimatedMessageId,
      setHighLightedMessageId,
      animatedMessageId,
      highLightedMessageId,
      nicknamesMap,
      emojiAllMap,
      onScrollCallback,
      onScrollDownCallback,
      scrollRef,
      scrollBehavior,
      toggleReaction,
      isScrolled,
      setIsScrolled
    }
  }, import_react15.default.createElement(UserProfileProvider, {
    disableUserProfile: (_f = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _f !== void 0 ? _f : config === null || config === void 0 ? void 0 : config.disableUserProfile,
    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,
    onUserProfileMessage
  }, children));
};
var useChannelContext = function() {
  return import_react15.default.useContext(ChannelContext);
};

// node_modules/@sendbird/uikit-react/Channel/components/TypingIndicator.js
var import_react16 = __toESM(require_react(), 1);
var import_prop_types8 = __toESM(require_prop_types(), 1);
var TypingIndicatorText = function(_a) {
  var members = _a.members;
  var stringSet = (0, import_react16.useContext)(LocalizationContext).stringSet;
  if (!members || members.length === 0) {
    return "";
  }
  if (members && members.length === 1) {
    return "".concat(members[0].nickname, " ").concat(stringSet.TYPING_INDICATOR__IS_TYPING);
  }
  if (members && members.length === 2) {
    return "".concat(members[0].nickname, " ").concat(stringSet.TYPING_INDICATOR__AND, " ").concat(members[1].nickname, " ").concat(stringSet.TYPING_INDICATOR__ARE_TYPING);
  }
  return stringSet.TYPING_INDICATOR__MULTIPLE_TYPING;
};
var TypingIndicator = function() {
  var _a, _b, _c;
  var channelUrl = useChannelContext().channelUrl;
  var globalStore = useSendbirdStateContext();
  var sb = (_b = (_a = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _a === void 0 ? void 0 : _a.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;
  var logger = (_c = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config) === null || _c === void 0 ? void 0 : _c.logger;
  var _d = (0, import_react16.useState)(uuidv4()), handlerId = _d[0], setHandlerId = _d[1];
  var _e = (0, import_react16.useState)([]), typingMembers = _e[0], setTypingMembers = _e[1];
  (0, import_react16.useEffect)(function() {
    var _a2;
    if ((_a2 = sb === null || sb === void 0 ? void 0 : sb.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.addGroupChannelHandler) {
      sb.groupChannel.removeGroupChannelHandler(handlerId);
      var newHandlerId = uuidv4();
      var handler = new qe({
        onTypingStatusUpdated: function(groupChannel) {
          logger.info("Channel > Typing Indicator: onTypingStatusUpdated", groupChannel);
          if (groupChannel.url === channelUrl) {
            var members = groupChannel.getTypingUsers();
            setTypingMembers(members);
          }
        }
      });
      sb.groupChannel.addGroupChannelHandler(newHandlerId, handler);
      setHandlerId(newHandlerId);
    }
    return function() {
      var _a3;
      setTypingMembers([]);
      if ((_a3 = sb === null || sb === void 0 ? void 0 : sb.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler) {
        sb.groupChannel.removeGroupChannelHandler(handlerId);
      }
    };
  }, [channelUrl]);
  return import_react16.default.createElement(Label, {
    className: "sendbird-conversation__footer__typing-indicator__text",
    type: LabelTypography.CAPTION_2,
    color: LabelColors.ONBACKGROUND_2
  }, import_react16.default.createElement(TypingIndicatorText, {
    members: typingMembers
  }));
};

// node_modules/@sendbird/uikit-react/useLongPress-f8655a14.js
var import_react17 = __toESM(require_react(), 1);
var DEFAULT_DURATION = 300;
function preventDefault(e2) {
  if (!isTouchEvent(e2)) {
    return;
  }
  if (e2.touches.length < 2 && e2.preventDefault) {
    e2.preventDefault();
  }
}
function isTouchEvent(e2) {
  return e2 && "touches" in e2;
}
function useLongPress(_a, _b) {
  var onLongPress = _a.onLongPress, onClick = _a.onClick;
  var _c = _b === void 0 ? {} : _b, _d = _c.delay, delay = _d === void 0 ? DEFAULT_DURATION : _d, _e = _c.shouldPreventDefault, shouldPreventDefault = _e === void 0 ? true : _e, _f = _c.shouldStopPropagation, shouldStopPropagation = _f === void 0 ? false : _f;
  var isMobile = useMediaQueryContext().isMobile;
  var _g = (0, import_react17.useState)(false), longPressTriggered = _g[0], setLongPressTriggered = _g[1];
  var _h = (0, import_react17.useState)(false), dragTriggered = _h[0], setDragTriggered = _h[1];
  var timeout = (0, import_react17.useRef)();
  var target = (0, import_react17.useRef)();
  var start = (0, import_react17.useCallback)(function(e2) {
    e2.persist();
    var clonedEvent = __assign({}, e2);
    setDragTriggered(false);
    if (shouldStopPropagation) {
      e2.stopPropagation();
    }
    if (shouldPreventDefault && e2.target) {
      e2.target.addEventListener("touchend", preventDefault, {
        passive: false
      });
      target.current = e2.target;
    }
    timeout.current = setTimeout(function() {
      onLongPress(clonedEvent);
      setLongPressTriggered(true);
    }, delay);
  }, [onLongPress, delay, shouldPreventDefault, shouldStopPropagation, isMobile]);
  var clear = (0, import_react17.useCallback)(function(e2, shouldTriggerClick, onDrag) {
    if (shouldTriggerClick === void 0) {
      shouldTriggerClick = true;
    }
    if (onDrag === void 0) {
      onDrag = false;
    }
    if (onDrag) {
      setDragTriggered(true);
    } else {
      setDragTriggered(false);
    }
    if (timeout === null || timeout === void 0 ? void 0 : timeout.current) {
      clearTimeout(timeout.current);
    }
    if (shouldTriggerClick && !longPressTriggered && !dragTriggered) {
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    }
    setLongPressTriggered(false);
    if (shouldPreventDefault && target.current) {
      target.current.removeEventListener("touchend", preventDefault);
    }
  }, [shouldPreventDefault, onClick, longPressTriggered, dragTriggered]);
  return {
    onMouseDown: function(e2) {
      return start(e2);
    },
    onMouseUp: function(e2) {
      return clear(e2);
    },
    onMouseLeave: function(e2) {
      return clear(e2, false);
    },
    onTouchStart: function(e2) {
      return start(e2);
    },
    // setDragTriggered as true on touchmove, so that next onTouchEnd is ignored
    // if we dont do it, onClick?.(e) will be triggred, see inside clear()
    onTouchMove: function(e2) {
      return clear(e2, false, true);
    },
    onTouchEnd: function(e2) {
      return clear(e2);
    }
  };
}

// node_modules/@sendbird/uikit-react/ui/PlaceHolder.js
var import_react18 = __toESM(require_react(), 1);
var import_prop_types9 = __toESM(require_prop_types(), 1);
var PlaceHolderTypes = {
  LOADING: "LOADING",
  NO_CHANNELS: "NO_CHANNELS",
  NO_MESSAGES: "NO_MESSAGES",
  WRONG: "WRONG",
  SEARCH_IN: "SEARCH_IN",
  SEARCHING: "SEARCHING",
  NO_RESULTS: "NO_RESULTS"
};
function PlaceHolder(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, type = _a.type, iconSize = _a.iconSize, _c = _a.searchInString, searchInString = _c === void 0 ? "" : _c, _d = _a.retryToConnect, retryToConnect = _d === void 0 ? null : _d;
  var stringSet = (0, import_react18.useContext)(LocalizationContext).stringSet;
  return import_react18.default.createElement("div", {
    className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), ["sendbird-place-holder"], false).join(" ")
  }, type === PlaceHolderTypes.LOADING && import_react18.default.createElement(Loader, {
    width: iconSize || "48px",
    height: iconSize || "48px"
  }, import_react18.default.createElement(Icon, {
    type: IconTypes.SPINNER,
    fillColor: IconColors.PRIMARY,
    width: iconSize || "48px",
    height: iconSize || "48px"
  })), (type === PlaceHolderTypes.NO_CHANNELS || type === PlaceHolderTypes.NO_MESSAGES || type === PlaceHolderTypes.WRONG) && import_react18.default.createElement("div", {
    className: "sendbird-place-holder__body"
  }, type === PlaceHolderTypes.NO_CHANNELS && import_react18.default.createElement(Icon, {
    className: "sendbird-place-holder__body__icon",
    type: IconTypes.CHAT,
    fillColor: IconColors.ON_BACKGROUND_3,
    width: iconSize || "64px",
    height: iconSize || "64px"
  }), type === PlaceHolderTypes.WRONG && import_react18.default.createElement(Icon, {
    className: "sendbird-place-holder__body__icon",
    type: IconTypes.ERROR,
    fillColor: IconColors.ON_BACKGROUND_3,
    width: iconSize || "64px",
    height: iconSize || "64px"
  }), type === PlaceHolderTypes.NO_MESSAGES && import_react18.default.createElement(Icon, {
    className: "sendbird-place-holder__body__icon",
    type: IconTypes.MESSAGE,
    fillColor: IconColors.ON_BACKGROUND_3,
    width: iconSize || "64px",
    height: iconSize || "64px"
  }), import_react18.default.createElement(Label, {
    className: "sendbird-place-holder__body__text",
    type: LabelTypography.BODY_1,
    color: LabelColors.ONBACKGROUND_2
  }, type === PlaceHolderTypes.NO_CHANNELS && stringSet.PLACE_HOLDER__NO_CHANNEL, type === PlaceHolderTypes.WRONG && stringSet.PLACE_HOLDER__WRONG, type === PlaceHolderTypes.NO_MESSAGES && stringSet.PLACE_HOLDER__NO_MESSAGES), retryToConnect && import_react18.default.createElement("div", {
    className: "sendbird-place-holder__body__reconnect",
    role: "button",
    onClick: retryToConnect,
    onKeyPress: retryToConnect,
    tabIndex: 0
  }, import_react18.default.createElement(Icon, {
    className: "sendbird-place-holder__body__reconnect__icon",
    type: IconTypes.REFRESH,
    fillColor: IconColors.PRIMARY,
    width: "20px",
    height: "20px"
  }), import_react18.default.createElement(Label, {
    className: "sendbird-place-holder__body__reconnect__text",
    type: LabelTypography.BUTTON_1,
    color: LabelColors.PRIMARY
  }, stringSet.PLACE_HOLDER__RETRY_TO_CONNECT))), (type === PlaceHolderTypes.NO_RESULTS || type === PlaceHolderTypes.SEARCH_IN || type === PlaceHolderTypes.SEARCHING) && import_react18.default.createElement("div", {
    className: "sendbird-place-holder__body--align-top"
  }, type === PlaceHolderTypes.SEARCH_IN && import_react18.default.createElement("div", {
    className: "sendbird-place-holder__body--align-top__text"
  }, import_react18.default.createElement(Label, {
    className: "sendbird-place-holder__body--align-top__text__search-in",
    type: LabelTypography.BUTTON_2,
    color: LabelColors.ONBACKGROUND_2
  }, stringSet.SEARCH_IN), import_react18.default.createElement(Label, {
    className: "sendbird-place-holder__body--align-top__text__channel-name",
    type: LabelTypography.BUTTON_2,
    color: LabelColors.PRIMARY
  }, "'".concat(searchInString)), import_react18.default.createElement(Label, {
    className: "sendbird-place-holder__body--align-top__text__quote",
    type: LabelTypography.BUTTON_2,
    color: LabelColors.PRIMARY
  }, "'")), type === PlaceHolderTypes.SEARCHING && import_react18.default.createElement(Label, {
    className: "sendbird-place-hlder__body--align-top__searching",
    type: LabelTypography.BODY_1,
    color: LabelColors.ONBACKGROUND_2
  }, stringSet.SEARCHING), type === PlaceHolderTypes.NO_RESULTS && import_react18.default.createElement(Label, {
    className: "sendbird-place-hlder__body--align-top__no-result",
    type: LabelTypography.BODY_1,
    color: LabelColors.ONBACKGROUND_2
  }, stringSet.NO_SEARCHED_MESSAGE)));
}

export {
  PUBSUB_TOPICS,
  UserProfileContext,
  UserProfileProvider,
  getBorderRadiusForMultipleImageRenderer,
  ImageRenderer,
  Avatar$1,
  getSdk,
  getCreateGroupChannel,
  UserProfile,
  MenuItems,
  EmojiListItems,
  MenuItem,
  ContextMenu,
  UserListItem,
  ChannelAvatar,
  format,
  Loader,
  isSameDay,
  getChannelTitle,
  getLastMessageCreatedAt,
  getTotalMembers,
  getLastMessage,
  getChannelUnreadMessageCount,
  MessageStatus,
  MENTION_USER_LABEL_CLASSNAME,
  Colors,
  changeColorToClassName,
  TextButton,
  MAX_USER_MENTION_COUNT,
  MAX_USER_SUGGESTION_COUNT,
  USER_MENTION_TEMP_CHAR,
  ThreadReplySelectType,
  scrollIntoLast,
  isOperator,
  isDisabledBecauseFrozen,
  isDisabledBecauseMuted,
  isSameGroup,
  isAboutSame,
  ChannelProvider,
  useChannelContext,
  TypingIndicatorText,
  TypingIndicator,
  useLongPress,
  PlaceHolderTypes,
  PlaceHolder
};
//# sourceMappingURL=chunk-NGARSEYB.js.map
