import { _ as __assign, a as __awaiter, b as __generator, c as __spreadArray } from './tslib.es6-c2fb729e.js';
import React__default, { useLayoutEffect, useState, useEffect, useCallback, useMemo, useReducer } from 'react';
import { UIKitConfigProvider, useUIKitConfig } from '@sendbird/uikit-tools';
import { SendbirdSdkContext } from './withSendbird.js';
import cssVars from 'css-vars-ponyfill';
import { K } from './index-09847c0f.js';
import { U as USER_ACTIONS } from './actionTypes-324495ed.js';
import SendbirdChat, { ConnectionHandler, SendbirdProduct, SendbirdPlatform, DeviceOsPlatform } from '@sendbird/chat';
import { u as uuidv4 } from './uuid-c15b8b3b.js';
import { OpenChannelModule } from '@sendbird/chat/openChannel';
import { GroupChannelModule } from '@sendbird/chat/groupChannel';
import { i as isTextuallyNull } from './index-776554c0.js';
import { n as noop } from './utils-6c50a6d1.js';
import { V as VoicePlayerProvider } from './index-e04159fe.js';
import { VoiceRecorderProvider } from './VoiceRecorder/context.js';
import { L as LocalizationProvider } from './LocalizationContext-287ee149.js';
import { u as useMediaQueryContext, M as MediaQueryProvider } from './MediaQueryContext-114ca049.js';
import { g as getStringSet } from './stringSet-6422c6b9.js';
import { D as DEFAULT_MULTIPLE_FILES_MESSAGE_LIMIT, V as VOICE_RECORDER_DEFAULT_MAX, a as VOICE_RECORDER_DEFAULT_MIN } from './consts-d9c5f25a.js';
import { g as getCaseResolvedReplyType, a as getCaseResolvedThreadReplySelectType } from './resolvedReplyType-fb987595.js';
import { GlobalModalProvider } from './hooks/useModal.js';
export { useSendbirdStateContext } from './useSendbirdStateContext.js';
import './utils/message/getOutgoingMessageState.js';
import './ui/Modal.js';
import 'react-dom';
import './index-04bd1a59.js';
import './ui/IconButton.js';
import './ui/Button.js';
import './index-92741c7e.js';
import 'prop-types';
import './types-9d43ac6e.js';
import './ui/Icon.js';
import './index-e4277f9c.js';
import './_rollupPluginBabelHelpers-e92eb032.js';

var isEmpty = function (obj) {
  if (obj === null || obj === undefined) {
    return true;
  }
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return JSON.stringify(obj) === JSON.stringify({});
};
var useTheme = function (overrides) {
  useLayoutEffect(function () {
    if (!isEmpty(overrides)) {
      cssVars({
        variables: __assign({
          '--sendbird-dark-primary-500': '#4d2aa6',
          '--sendbird-dark-primary-400': '#6440C4',
          '--sendbird-dark-primary-300': '#7B53EF',
          '--sendbird-dark-primary-200': '#9E8CF5',
          '--sendbird-dark-primary-100': '#E2DFFF',
          '--sendbird-dark-secondary-500': '#007A7A',
          '--sendbird-dark-secondary-400': '#189A8D',
          '--sendbird-dark-secondary-300': '#2EBA9F',
          '--sendbird-dark-secondary-200': '#6FD6BE',
          '--sendbird-dark-secondary-100': '#AEF2DC',
          '--sendbird-dark-information-100': '#b2d9ff',
          '--sendbird-dark-error-500': '#A30E2D',
          '--sendbird-dark-error-400': '#C11F41',
          '--sendbird-dark-error-300': '#E53157',
          '--sendbird-dark-error-200': '#FF6183',
          '--sendbird-dark-error-100': '#FFABBD',
          '--sendbird-dark-background-700': '#000000',
          '--sendbird-dark-background-600': '#161616',
          '--sendbird-dark-background-500': '#2C2C2C',
          '--sendbird-dark-background-400': '#393939',
          '--sendbird-dark-background-300': '#A8A8A8',
          '--sendbird-dark-background-200': '#D9D9D9',
          '--sendbird-dark-background-100': '#F0F0F0',
          '--sendbird-dark-background-50': '#FFFFFF',
          '--sendbird-dark-overlay': 'rgba(0, 0, 0, 0.32)',
          '--sendbird-dark-onlight-01': 'rgba(0, 0, 0, 0.88)',
          '--sendbird-dark-onlight-02': 'rgba(0, 0, 0, 0.50)',
          '--sendbird-dark-onlight-03': 'rgba(0, 0, 0, 0.38)',
          '--sendbird-dark-onlight-04': 'rgba(0, 0, 0, 0.12)',
          '--sendbird-dark-ondark-01': 'rgba(255, 255, 255, 0.88)',
          '--sendbird-dark-ondark-02': 'rgba(255, 255, 255, 0.50)',
          '--sendbird-dark-ondark-03': 'rgba(255, 255, 255, 0.38)',
          '--sendbird-dark-ondark-04': 'rgba(255, 255, 255, 0.12)',
          '--sendbird-dark-shadow-01': '0 1px 5px 0 rgba(33, 34, 66, 0.04), 0 0 3px 0 rgba(0, 0, 0, 0.08), 0 2px 1px 0 rgba(0, 0, 0, 0.12)',
          '--sendbird-dark-shadow-02': '0 3px 5px -3px rgba(33, 34, 66, 0.04), 0 3px 14px 2px rgba(0, 0, 0, 0.08), 0 8px 10px 1px rgba(0, 0, 0, 0.12)',
          '--sendbird-dark-shadow-03': '0 6px 10px -5px rgba(0, 0, 0, 0.04), 0 6px 30px 5px rgba(0, 0, 0, 0.08), 0 16px 24px 2px rgba(0, 0, 0, 0.12)',
          '--sendbird-dark-shadow-04': '0 9px 15px -7px rgba(0, 0, 0, 0.04), 0 9px 46px 8px rgba(0, 0, 0, 0.08), 0 24px 38px 3px rgba(0, 0, 0, 0.12)',
          '--sendbird-dark-shadow-message-input': '0 1px 5px 0 rgba(33, 34, 66, 0.12), 0 0 1px 0 rgba(33, 34, 66, 0.16), 0 2px 1px 0 rgba(33, 34, 66, 0.08), 0 1px 5px 0 rgba(0, 0, 0, 0.12)',
          '--sendbird-light-primary-500': '#4d2aa6',
          '--sendbird-light-primary-400': '#6440C4',
          '--sendbird-light-primary-300': '#7B53EF',
          '--sendbird-light-primary-200': '#9E8CF5',
          '--sendbird-light-primary-100': '#E2DFFF',
          '--sendbird-light-secondary-500': '#007A7A',
          '--sendbird-light-secondary-400': '#189A8D',
          '--sendbird-light-secondary-300': '#2EBA9F',
          '--sendbird-light-secondary-200': '#6FD6BE',
          '--sendbird-light-secondary-100': '#AEF2DC',
          '--sendbird-light-information-100': '#b2d9ff',
          '--sendbird-light-error-500': '#A30E2D',
          '--sendbird-light-error-400': '#C11F41',
          '--sendbird-light-error-300': '#E53157',
          '--sendbird-light-error-200': '#FF6183',
          '--sendbird-light-error-100': '#FFABBD',
          '--sendbird-light-background-700': '#000000',
          '--sendbird-light-background-600': '#161616',
          '--sendbird-light-background-500': '#2C2C2C',
          '--sendbird-light-background-400': '#393939',
          '--sendbird-light-background-300': '#A8A8A8',
          '--sendbird-light-background-200': '#D9D9D9',
          '--sendbird-light-background-100': '#F0F0F0',
          '--sendbird-light-background-50': ' #FFFFFF',
          '--sendbird-light-overlay': 'rgba(0, 0, 0, 0.32)',
          '--sendbird-light-onlight-01': 'rgba(0, 0, 0, 0.88)',
          '--sendbird-light-onlight-02': 'rgba(0, 0, 0, 0.50)',
          '--sendbird-light-onlight-03': 'rgba(0, 0, 0, 0.38)',
          '--sendbird-light-onlight-04': 'rgba(0, 0, 0, 0.12)',
          '--sendbird-light-ondark-01': 'rgba(255, 255, 255, 0.88)',
          '--sendbird-light-ondark-02': 'rgba(255, 255, 255, 0.50)',
          '--sendbird-light-ondark-03': 'rgba(255, 255, 255, 0.38)',
          '--sendbird-light-ondark-04': 'rgba(255, 255, 255, 0.12)',
          '--sendbird-light-shadow-01': '0 1px 5px 0 rgba(33, 34, 66, 0.04), 0 0 3px 0 rgba(0, 0, 0, 0.08), 0 2px 1px 0 rgba(0, 0, 0, 0.12)',
          '--sendbird-light-shadow-02': '0 3px 5px -3px rgba(33, 34, 66, 0.04), 0 3px 14px 2px rgba(0, 0, 0, 0.08), 0 8px 10px 1px rgba(0, 0, 0, 0.12)',
          '--sendbird-light-shadow-03': '0 6px 10px -5px rgba(0, 0, 0, 0.04), 0 6px 30px 5px rgba(0, 0, 0, 0.08), 0 16px 24px 2px rgba(0, 0, 0, 0.12)',
          '--sendbird-light-shadow-04': '0 9px 15px -7px rgba(0, 0, 0, 0.04), 0 9px 46px 8px rgba(0, 0, 0, 0.08), 0 24px 38px 3px rgba(0, 0, 0, 0.12)',
          '--sendbird-light-shadow-message-input': '0 1px 5px 0 rgba(33, 34, 66, 0.12), 0 0 1px 0 rgba(33, 34, 66, 0.16), 0 2px 1px 0 rgba(33, 34, 66, 0.08), 0 1px 5px 0 rgba(0, 0, 0, 0.12)'
        }, overrides)
      });
    }
  }, [overrides]);
};

var SDK_ACTIONS = {
  INIT_SDK: 'INIT_SDK',
  SET_SDK_LOADING: 'SET_SDK_LOADING',
  RESET_SDK: 'RESET_SDK',
  SDK_ERROR: 'SDK_ERROR'
};

var initialState$1 = {
  initialized: false,
  loading: false,
  sdk: {},
  error: false
};

function reducer$1(state, action) {
  return K(action).with({
    type: SDK_ACTIONS.SET_SDK_LOADING
  }, function (_a) {
    var payload = _a.payload;
    return __assign(__assign({}, state), {
      initialized: false,
      loading: payload
    });
  }).with({
    type: SDK_ACTIONS.SDK_ERROR
  }, function () {
    return __assign(__assign({}, state), {
      initialized: false,
      loading: false,
      error: true
    });
  }).with({
    type: SDK_ACTIONS.INIT_SDK
  }, function (_a) {
    var payload = _a.payload;
    return {
      sdk: payload,
      initialized: true,
      loading: false,
      error: false
    };
  }).with({
    type: SDK_ACTIONS.RESET_SDK
  }, function () {
    return initialState$1;
  }).otherwise(function () {
    return state;
  });
}

var initialState = {
  initialized: false,
  loading: false,
  user: {}
};

function reducer(state, action) {
  return K(action).with({
    type: USER_ACTIONS.INIT_USER
  }, function (_a) {
    var payload = _a.payload;
    return {
      initialized: true,
      loading: false,
      user: payload
    };
  }).with({
    type: USER_ACTIONS.RESET_USER
  }, function () {
    return initialState;
  }).with({
    type: USER_ACTIONS.UPDATE_USER_INFO
  }, function (_a) {
    var payload = _a.payload;
    return __assign(__assign({}, state), {
      user: payload
    });
  }).otherwise(function () {
    return state;
  });
}

function useOnlineStatus(sdk, logger) {
  var _a, _b;
  var _c = useState((_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true),
    isOnline = _c[0],
    setIsOnline = _c[1];
  useEffect(function () {
    var uniqueHandlerId = uuidv4();
    try {
      logger.warning('sdk changed', uniqueHandlerId);
      var handler = new ConnectionHandler({
        onDisconnected: function () {
          setIsOnline(false);
          logger.warning('onDisconnected', {
            isOnline: isOnline
          });
        },
        onReconnectStarted: function () {
          setIsOnline(false);
          logger.warning('onReconnectStarted', {
            isOnline: isOnline
          });
        },
        onReconnectSucceeded: function () {
          setIsOnline(true);
          logger.warning('onReconnectSucceeded', {
            isOnline: isOnline
          });
        },
        onReconnectFailed: function () {
          sdk.reconnect();
          logger.warning('onReconnectFailed');
        }
      });
      if (sdk === null || sdk === void 0 ? void 0 : sdk.addConnectionHandler) {
        // workaround -> addConnectionHandler invalidates session handler
        // provided through configureSession
        sdk.addConnectionHandler(uniqueHandlerId, handler);
        logger.info('Added ConnectionHandler', uniqueHandlerId);
      }
    } catch (_a) {
      //
    }
    return function () {
      try {
        sdk.removeConnectionHandler(uniqueHandlerId);
        logger.info('Removed ConnectionHandler', uniqueHandlerId);
      } catch (_a) {
        //
      }
    };
  }, [sdk]);
  useEffect(function () {
    var tryReconnect = function () {
      try {
        logger.warning('Try reconnecting SDK');
        if (sdk.connectionState !== 'OPEN') {
          // connection is not broken yet
          sdk.reconnect();
        }
      } catch (_a) {
        //
      }
    };
    // addEventListener version
    window.addEventListener('online', tryReconnect);
    return function () {
      window.removeEventListener('online', tryReconnect);
    };
  }, [sdk]);
  // add offline-class to body
  useEffect(function () {
    var body = document.querySelector('body');
    if (!isOnline) {
      try {
        body.classList.add('sendbird__offline');
        logger.info('Added class sendbird__offline to body');
      } catch (e) {
        //
      }
    } else {
      try {
        body.classList.remove('sendbird__offline');
        logger.info('Removed class sendbird__offline from body');
      } catch (e) {
        //
      }
    }
  }, [isOnline]);
  return isOnline;
}

function disconnectSdk(_a) {
  var sdkDispatcher = _a.sdkDispatcher,
    userDispatcher = _a.userDispatcher,
    sdk = _a.sdk;
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_b) {
      return [2 /*return*/, new Promise(function (resolve) {
        sdkDispatcher({
          type: SDK_ACTIONS.SET_SDK_LOADING,
          payload: true
        });
        if (sdk === null || sdk === void 0 ? void 0 : sdk.disconnect) {
          sdk.disconnect().then(function () {
            sdkDispatcher({
              type: SDK_ACTIONS.RESET_SDK
            });
            userDispatcher({
              type: USER_ACTIONS.RESET_USER
            });
          }).finally(function () {
            resolve(true);
          });
        } else {
          resolve(true);
        }
      })];
    });
  });
}

var APP_VERSION_STRING = '3.7.0';
var INIT_SDK = SDK_ACTIONS.INIT_SDK,
  SET_SDK_LOADING = SDK_ACTIONS.SET_SDK_LOADING,
  RESET_SDK = SDK_ACTIONS.RESET_SDK,
  SDK_ERROR = SDK_ACTIONS.SDK_ERROR;
var INIT_USER = USER_ACTIONS.INIT_USER,
  UPDATE_USER_INFO = USER_ACTIONS.UPDATE_USER_INFO,
  RESET_USER = USER_ACTIONS.RESET_USER;
function getMissingParamError(_a) {
  var userId = _a.userId,
    appId = _a.appId;
  return "SendbirdProvider | useConnect/setupConnection/Connection failed UserId: ".concat(userId, " or appId: ").concat(appId, " missing");
}
function getConnectSbError(error) {
  return "SendbirdProvider | useConnect/setupConnection/Connection failed. ".concat((error === null || error === void 0 ? void 0 : error.code) || '', " ").concat((error === null || error === void 0 ? void 0 : error.message) || '');
}
function setUpParams(_a) {
  var appId = _a.appId,
    customApiHost = _a.customApiHost,
    customWebSocketHost = _a.customWebSocketHost,
    sdkInitParams = _a.sdkInitParams;
  var params = __assign(__assign({
    modules: [new GroupChannelModule(), new OpenChannelModule()],
    newInstance: true
  }, sdkInitParams !== null && sdkInitParams !== void 0 ? sdkInitParams : {}), {
    // appId shouldn't be overrided
    appId: appId
  });
  if (customApiHost) {
    params['customApiHost'] = customApiHost;
  }
  if (customWebSocketHost) {
    params['customWebSocketHost'] = customWebSocketHost;
  }
  var newSdk = SendbirdChat.init(params);
  return newSdk;
}
// Steps
// 1. Check if minimum userID/appID is provided
//  1.a. If not, throw error > !reject
//  1.b. If yes, continue
// 2. Set up params with custom host if provided
// 3. Set up session handler if provided
// 4. Set up version
// 5. Connect to Sendbird -> either using user ID or (user ID + access token)
// 6. If connected, connectCbSucess
//  6.a check if nickname is to be updated -> no > !resolve immediately
//  6.b check if nickname is to be updated -> yes > update nickname > !resolve
// 7. If not connected, connectCbError > !reject
function setUpConnection(_a) {
  var logger = _a.logger,
    sdkDispatcher = _a.sdkDispatcher,
    userDispatcher = _a.userDispatcher,
    initDashboardConfigs = _a.initDashboardConfigs,
    userId = _a.userId,
    appId = _a.appId,
    customApiHost = _a.customApiHost,
    customWebSocketHost = _a.customWebSocketHost,
    configureSession = _a.configureSession,
    nickname = _a.nickname,
    profileUrl = _a.profileUrl,
    accessToken = _a.accessToken,
    isUserIdUsedForNickname = _a.isUserIdUsedForNickname,
    sdkInitParams = _a.sdkInitParams,
    customExtensionParams = _a.customExtensionParams,
    _b = _a.isMobile,
    isMobile = _b === void 0 ? false : _b;
  return __awaiter(this, void 0, void 0, function () {
    var _this = this;
    return __generator(this, function (_c) {
      return [2 /*return*/, new Promise(function (resolve, reject) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/setupConnection/init', {
          userId: userId,
          appId: appId
        });
        sdkDispatcher({
          type: SET_SDK_LOADING,
          payload: true
        });
        if (userId && appId) {
          var newSdk_1 = setUpParams({
            appId: appId,
            customApiHost: customApiHost,
            customWebSocketHost: customWebSocketHost,
            sdkInitParams: sdkInitParams
          });
          if (configureSession && typeof configureSession === 'function') {
            var sessionHandler = configureSession(newSdk_1);
            (_b = logger === null || logger === void 0 ? void 0 : logger.info) === null || _b === void 0 ? void 0 : _b.call(logger, 'SendbirdProvider | useConnect/setupConnection/configureSession', sessionHandler);
            newSdk_1.setSessionHandler(sessionHandler);
          }
          (_c = logger === null || logger === void 0 ? void 0 : logger.info) === null || _c === void 0 ? void 0 : _c.call(logger, 'SendbirdProvider | useConnect/setupConnection/setVersion', {
            version: APP_VERSION_STRING
          });
          /**
           * Keep optional chaining to the addSendbirdExtensions
           * for supporting the ChatSDK v4.9.5 or less
           */
          (_d = newSdk_1 === null || newSdk_1 === void 0 ? void 0 : newSdk_1.addSendbirdExtensions) === null || _d === void 0 ? void 0 : _d.call(newSdk_1, [{
            product: (_e = SendbirdProduct === null || SendbirdProduct === void 0 ? void 0 : SendbirdProduct.UIKIT_CHAT) !== null && _e !== void 0 ? _e : 'uikit-chat',
            version: APP_VERSION_STRING,
            platform: (_f = SendbirdPlatform === null || SendbirdPlatform === void 0 ? void 0 : SendbirdPlatform.JS) !== null && _f !== void 0 ? _f : 'js'
          }], {
            platform: isMobile ? (_g = DeviceOsPlatform === null || DeviceOsPlatform === void 0 ? void 0 : DeviceOsPlatform.MOBILE_WEB) !== null && _g !== void 0 ? _g : 'mobile_web' : (_h = DeviceOsPlatform === null || DeviceOsPlatform === void 0 ? void 0 : DeviceOsPlatform.WEB) !== null && _h !== void 0 ? _h : 'web'
          }, customExtensionParams);
          newSdk_1.addExtension('sb_uikit', APP_VERSION_STRING);
          var connectCbSucess_1 = function (user) {
            return __awaiter(_this, void 0, void 0, function () {
              var _a, _b;
              return __generator(this, function (_c) {
                (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/setupConnection/connectCbSucess', user);
                sdkDispatcher({
                  type: INIT_SDK,
                  payload: newSdk_1
                });
                userDispatcher({
                  type: INIT_USER,
                  payload: user
                });
                initDashboardConfigs(newSdk_1).then(function (config) {
                  var _a;
                  (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/setupConnection/getUIKitConfiguration success', {
                    config: config
                  });
                }).catch(function (error) {
                  var _a;
                  (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/setupConnection/getUIKitConfiguration failed', {
                    error: error
                  });
                });
                // use nickname/profileUrl if provided
                // or set userID as nickname
                if ((nickname !== user.nickname || profileUrl !== user.profileUrl) && !(isTextuallyNull(nickname) && isTextuallyNull(profileUrl))) {
                  (_b = logger === null || logger === void 0 ? void 0 : logger.info) === null || _b === void 0 ? void 0 : _b.call(logger, 'SendbirdProvider | useConnect/setupConnection/updateCurrentUserInfo', {
                    nickname: nickname,
                    profileUrl: profileUrl
                  });
                  newSdk_1.updateCurrentUserInfo({
                    nickname: nickname || user.nickname || (isUserIdUsedForNickname ? user.userId : ''),
                    profileUrl: profileUrl || user.profileUrl
                  }).then(function (namedUser) {
                    var _a;
                    (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/setupConnection/updateCurrentUserInfo success', {
                      nickname: nickname,
                      profileUrl: profileUrl
                    });
                    userDispatcher({
                      type: UPDATE_USER_INFO,
                      payload: namedUser
                    });
                  }).finally(function () {
                    resolve();
                  });
                } else {
                  resolve();
                }
                return [2 /*return*/];
              });
            });
          };

          var connectCbError_1 = function (e) {
            var _a;
            var errorMessage = getConnectSbError(e);
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, errorMessage, {
              e: e,
              appId: appId,
              userId: userId
            });
            sdkDispatcher({
              type: RESET_SDK
            });
            userDispatcher({
              type: RESET_USER
            });
            sdkDispatcher({
              type: SDK_ERROR
            });
            // exit promise with error
            reject(errorMessage);
          };
          (_j = logger === null || logger === void 0 ? void 0 : logger.info) === null || _j === void 0 ? void 0 : _j.call(logger, "SendbirdProvider | useConnect/setupConnection/connect connecting using ".concat(accessToken !== null && accessToken !== void 0 ? accessToken : userId));
          newSdk_1.connect(userId, accessToken).then(function (res) {
            return connectCbSucess_1(res);
          }).catch(function (err) {
            return connectCbError_1(err);
          });
        } else {
          var errorMessage = getMissingParamError({
            userId: userId,
            appId: appId
          });
          sdkDispatcher({
            type: SDK_ERROR
          });
          (_k = logger === null || logger === void 0 ? void 0 : logger.error) === null || _k === void 0 ? void 0 : _k.call(logger, errorMessage);
          // exit promise with error
          reject(errorMessage);
        }
      })];
    });
  });
}

function connect(_a) {
  var logger = _a.logger,
    sdkDispatcher = _a.sdkDispatcher,
    userDispatcher = _a.userDispatcher,
    initDashboardConfigs = _a.initDashboardConfigs,
    userId = _a.userId,
    appId = _a.appId,
    customApiHost = _a.customApiHost,
    customWebSocketHost = _a.customWebSocketHost,
    configureSession = _a.configureSession,
    nickname = _a.nickname,
    profileUrl = _a.profileUrl,
    accessToken = _a.accessToken,
    sdk = _a.sdk,
    sdkInitParams = _a.sdkInitParams,
    customExtensionParams = _a.customExtensionParams,
    isMobile = _a.isMobile;
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          return [4 /*yield*/, disconnectSdk({
            logger: logger,
            sdkDispatcher: sdkDispatcher,
            userDispatcher: userDispatcher,
            sdk: sdk
          })];
        case 1:
          _b.sent();
          return [4 /*yield*/, setUpConnection({
            logger: logger,
            sdkDispatcher: sdkDispatcher,
            userDispatcher: userDispatcher,
            initDashboardConfigs: initDashboardConfigs,
            userId: userId,
            appId: appId,
            customApiHost: customApiHost,
            customWebSocketHost: customWebSocketHost,
            configureSession: configureSession,
            nickname: nickname,
            profileUrl: profileUrl,
            accessToken: accessToken,
            sdkInitParams: sdkInitParams,
            customExtensionParams: customExtensionParams,
            isMobile: isMobile
          })];
        case 2:
          _b.sent();
          return [2 /*return*/];
      }
    });
  });
}

function useConnect(triggerTypes, staticTypes) {
  var _a;
  var userId = triggerTypes.userId,
    appId = triggerTypes.appId,
    accessToken = triggerTypes.accessToken,
    isMobile = triggerTypes.isMobile,
    isUserIdUsedForNickname = triggerTypes.isUserIdUsedForNickname;
  var logger = staticTypes.logger,
    nickname = staticTypes.nickname,
    profileUrl = staticTypes.profileUrl,
    configureSession = staticTypes.configureSession,
    customApiHost = staticTypes.customApiHost,
    customWebSocketHost = staticTypes.customWebSocketHost,
    sdk = staticTypes.sdk,
    sdkDispatcher = staticTypes.sdkDispatcher,
    userDispatcher = staticTypes.userDispatcher,
    initDashboardConfigs = staticTypes.initDashboardConfigs,
    sdkInitParams = staticTypes.sdkInitParams,
    customExtensionParams = staticTypes.customExtensionParams;
  (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect', __assign(__assign({}, triggerTypes), staticTypes));
  useEffect(function () {
    var _a, _b;
    (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/useEffect', {
      userId: userId,
      appId: appId,
      accessToken: accessToken
    });
    try {
      connect({
        userId: userId,
        appId: appId,
        accessToken: accessToken,
        logger: logger,
        nickname: nickname,
        profileUrl: profileUrl,
        configureSession: configureSession,
        customApiHost: customApiHost,
        customWebSocketHost: customWebSocketHost,
        sdk: sdk,
        sdkDispatcher: sdkDispatcher,
        userDispatcher: userDispatcher,
        initDashboardConfigs: initDashboardConfigs,
        isUserIdUsedForNickname: isUserIdUsedForNickname,
        sdkInitParams: sdkInitParams,
        customExtensionParams: customExtensionParams,
        isMobile: isMobile
      });
    } catch (error) {
      (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, 'SendbirdProvider | useConnect/useEffect', error);
    }
  }, [userId, appId, accessToken]);
  var reconnect = useCallback(function () {
    var _a, _b;
    (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, 'SendbirdProvider | useConnect/reconnect/useCallback', {
      sdk: sdk
    });
    try {
      connect({
        userId: userId,
        appId: appId,
        accessToken: accessToken,
        logger: logger,
        nickname: nickname,
        profileUrl: profileUrl,
        configureSession: configureSession,
        customApiHost: customApiHost,
        customWebSocketHost: customWebSocketHost,
        sdk: sdk,
        sdkDispatcher: sdkDispatcher,
        userDispatcher: userDispatcher,
        initDashboardConfigs: initDashboardConfigs,
        isUserIdUsedForNickname: isUserIdUsedForNickname,
        sdkInitParams: sdkInitParams,
        customExtensionParams: customExtensionParams,
        isMobile: isMobile
      });
    } catch (error) {
      (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, 'SendbirdProvider | useConnect/reconnect/useCallback', error);
    }
  }, [sdk]);
  return reconnect;
}

// Logger, pretty much explains it
// const [logger, setLogger] = useState(LoggerFactory(logLevel));
var LOG_LEVELS = {
  DEBUG: 'debug',
  WARNING: 'warning',
  ERROR: 'error',
  INFO: 'info',
  ALL: 'all'
};
var colorLog = function (level) {
  switch (level) {
    case LOG_LEVELS.WARNING:
      return 'color: Orange';
    case LOG_LEVELS.ERROR:
      return 'color: Red';
    default:
      return 'color: Gray';
  }
};
var printLog = function (_a) {
  var level = _a.level,
    title = _a.title,
    _b = _a.description,
    description = _b === void 0 ? '' : _b,
    _c = _a.payload,
    payload = _c === void 0 ? [] : _c;
  // eslint-disable-next-line no-console
  console.log.apply(console, __spreadArray(["%c SendbirdUIKit | ".concat(level, " | ").concat(new Date().toISOString(), " | ").concat(title, " ").concat(description && '|'), colorLog(level), description], payload, false));
};
var getDefaultLogger = function () {
  return {
    info: noop,
    error: noop,
    warning: noop
  };
};
var LoggerFactory = function (lvl, customInterface) {
  var logInterface = customInterface || printLog;
  var lvlArray = Array.isArray(lvl) ? lvl : [lvl];
  var applyLog = function (lgLvl) {
    return function (title, description) {
      var payload = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        payload[_i - 2] = arguments[_i];
      }
      return logInterface({
        level: lgLvl,
        title: title,
        description: description,
        payload: payload
      });
    };
  };
  return lvlArray.reduce(function (accumulator, currentLvl) {
    if (currentLvl === LOG_LEVELS.DEBUG || currentLvl === LOG_LEVELS.ALL) {
      return __assign(__assign({}, accumulator), {
        info: applyLog(LOG_LEVELS.INFO),
        error: applyLog(LOG_LEVELS.ERROR),
        warning: applyLog(LOG_LEVELS.WARNING)
      });
    }
    if (currentLvl === LOG_LEVELS.INFO) {
      return __assign(__assign({}, accumulator), {
        info: applyLog(LOG_LEVELS.INFO)
      });
    }
    if (currentLvl === LOG_LEVELS.ERROR) {
      return __assign(__assign({}, accumulator), {
        error: applyLog(LOG_LEVELS.ERROR)
      });
    }
    if (currentLvl === LOG_LEVELS.WARNING) {
      return __assign(__assign({}, accumulator), {
        warning: applyLog(LOG_LEVELS.WARNING)
      });
    }
    return __assign({}, accumulator);
  }, getDefaultLogger());
};
// TODO: Make this to hook, useLogger

// https://davidwalsh.name/pubsub-javascript
// we use pubsub to sync events between multiple components(example - ChannelList, Channel)
// for example, if customer sends a message from their custom component
// without pubsub,we would not be able to listen to it
// in our ChannelList or Conversation
var pubSubFactory = function () {
  var topics = {};
  var hOP = topics.hasOwnProperty;
  return {
    __getTopics: function () {
      return topics;
    },
    subscribe: function (topic, listener) {
      // Create the topic's object if not yet created
      if (!hOP.call(topics, topic)) {
        topics[topic] = [];
      }
      // Add the listener to queue
      var index = topics[topic].push(listener) - 1;
      // Provide handle back for removal of topic
      return {
        remove: function () {
          topics[topic].splice(index, 1);
        }
      };
    },
    publish: function (topic, info) {
      // If the topic doesn't exist, or there's no listeners in queue, just leave
      if (!hOP.call(topics, topic)) {
        return;
      }
      // Cycle through topics queue, fire!
      topics[topic].forEach(function (item) {
        item(info !== undefined ? info : {});
      });
    }
  };
};

function useAppendDomNode(ids, rootSelector) {
  if (ids === void 0) {
    ids = [];
  }
  if (rootSelector === void 0) {
    rootSelector = 'unknown';
  }
  useEffect(function () {
    var root = document.querySelector(rootSelector);
    if (root) {
      ids.forEach(function (id) {
        var elem = document.createElement('div');
        elem.setAttribute('id', id);
        root.appendChild(elem);
      });
    }
    return function () {
      if (root) {
        ids.forEach(function (id) {
          var target = document.getElementById(id);
          if (target) root.removeChild(target);
        });
      }
    };
  }, []);
}

var VoiceMessageProvider = function (_a) {
  var children = _a.children,
    _b = _a.isVoiceMessageEnabled,
    isVoiceMessageEnabled = _b === void 0 ? true : _b;
  if (!isVoiceMessageEnabled) {
    return /*#__PURE__*/React__default.createElement(VoicePlayerProvider, null, children);
  }
  return /*#__PURE__*/React__default.createElement(VoiceRecorderProvider, null, /*#__PURE__*/React__default.createElement(VoicePlayerProvider, null, children));
};

function uikitConfigMapper(_a) {
  var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
  var legacyConfig = _a.legacyConfig,
    _1 = _a.uikitOptions,
    uikitOptions = _1 === void 0 ? {} : _1;
  var replyType = legacyConfig.replyType,
    isMentionEnabled = legacyConfig.isMentionEnabled,
    isReactionEnabled = legacyConfig.isReactionEnabled,
    disableUserProfile = legacyConfig.disableUserProfile,
    isVoiceMessageEnabled = legacyConfig.isVoiceMessageEnabled,
    isTypingIndicatorEnabledOnChannelList = legacyConfig.isTypingIndicatorEnabledOnChannelList,
    isMessageReceiptStatusEnabledOnChannelList = legacyConfig.isMessageReceiptStatusEnabledOnChannelList,
    showSearchIcon = legacyConfig.showSearchIcon;
  return {
    common: {
      enableUsingDefaultUserProfile: (_c = (_b = uikitOptions.common) === null || _b === void 0 ? void 0 : _b.enableUsingDefaultUserProfile) !== null && _c !== void 0 ? _c : typeof disableUserProfile === 'boolean' ? !disableUserProfile : undefined
    },
    groupChannel: {
      enableOgtag: (_d = uikitOptions.groupChannel) === null || _d === void 0 ? void 0 : _d.enableOgtag,
      enableMention: (_f = (_e = uikitOptions.groupChannel) === null || _e === void 0 ? void 0 : _e.enableMention) !== null && _f !== void 0 ? _f : isMentionEnabled,
      enableReactions: (_h = (_g = uikitOptions.groupChannel) === null || _g === void 0 ? void 0 : _g.enableReactions) !== null && _h !== void 0 ? _h : isReactionEnabled,
      enableTypingIndicator: (_j = uikitOptions.groupChannel) === null || _j === void 0 ? void 0 : _j.enableTypingIndicator,
      enableVoiceMessage: (_l = (_k = uikitOptions.groupChannel) === null || _k === void 0 ? void 0 : _k.enableVoiceMessage) !== null && _l !== void 0 ? _l : isVoiceMessageEnabled,
      replyType: (_o = (_m = uikitOptions.groupChannel) === null || _m === void 0 ? void 0 : _m.replyType) !== null && _o !== void 0 ? _o : replyType != null ? getCaseResolvedReplyType(replyType).lowerCase : undefined,
      threadReplySelectType: (_p = uikitOptions.groupChannel) === null || _p === void 0 ? void 0 : _p.threadReplySelectType,
      input: {
        enableDocument: (_r = (_q = uikitOptions.groupChannel) === null || _q === void 0 ? void 0 : _q.input) === null || _r === void 0 ? void 0 : _r.enableDocument
      }
    },
    groupChannelList: {
      enableTypingIndicator: (_t = (_s = uikitOptions.groupChannelList) === null || _s === void 0 ? void 0 : _s.enableTypingIndicator) !== null && _t !== void 0 ? _t : isTypingIndicatorEnabledOnChannelList,
      enableMessageReceiptStatus: (_v = (_u = uikitOptions.groupChannelList) === null || _u === void 0 ? void 0 : _u.enableMessageReceiptStatus) !== null && _v !== void 0 ? _v : isMessageReceiptStatusEnabledOnChannelList
    },
    groupChannelSettings: {
      enableMessageSearch: (_x = (_w = uikitOptions.groupChannelSettings) === null || _w === void 0 ? void 0 : _w.enableMessageSearch) !== null && _x !== void 0 ? _x : showSearchIcon
    },
    openChannel: {
      enableOgtag: (_y = uikitOptions.openChannel) === null || _y === void 0 ? void 0 : _y.enableOgtag,
      input: {
        enableDocument: (_0 = (_z = uikitOptions.openChannel) === null || _z === void 0 ? void 0 : _z.input) === null || _0 === void 0 ? void 0 : _0.enableDocument
      }
    }
  };
}

var TIMEOUT = 2000;
/*
  * This is a factory function that returns a scheduler.
  * The scheduler is a queue that calls the callback function on intervals.
  * If interval is empty, the callback function is called immediately.
  * If interval is not empty, the callback function is called after the interval.
*/
function schedulerFactory(_a) {
  var logger = _a.logger,
    timeout = _a.timeout,
    cb = _a.cb;
  var queue = [];
  var interval = null;
  var push = function (channel) {
    var channelPresent = queue.find(function (c) {
      return c.url === channel.url;
    });
    if (!channelPresent) {
      queue.push(channel);
    } else {
      logger.info('Channel: Mark as read already in queue', {
        channel: channel
      });
    }
    // start the interval if it's not already running
    if (interval) {
      return;
    }
    var item = queue.shift();
    if (item) {
      cb(item);
    }
    interval = setInterval(function () {
      if (queue.length === 0 && interval) {
        clearInterval(interval);
        interval = null;
        return;
      }
      var item = queue.shift();
      if (item) {
        cb(item);
      }
    }, timeout || TIMEOUT);
  };
  var clear = function () {
    queue = [];
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  };
  return {
    push: push,
    clear: clear,
    getQueue: function () {
      return queue;
    }
  };
}

// this hook accepts a callback to run component is unmounted
function useUnmount(callback, deps) {
  if (deps === void 0) {
    deps = [];
  }
  useLayoutEffect(function () {
    return function () {
      callback();
    };
  }, deps);
}

function useMarkAsReadScheduler(_a, _b) {
  var isConnected = _a.isConnected;
  var logger = _b.logger;
  var markAsReadScheduler = useMemo(function () {
    return schedulerFactory({
      logger: logger,
      cb: function (channel) {
        try {
          channel.markAsRead();
        } catch (error) {
          logger.warning('Channel: Mark as delivered failed', {
            channel: channel,
            error: error
          });
        }
      }
    });
  }, []);
  useEffect(function () {
    // for simplicity, we clear the queue when the connection is lost
    if (!isConnected) {
      markAsReadScheduler.clear();
    }
  }, [isConnected]);
  useUnmount(function () {
    markAsReadScheduler.clear();
  });
  return markAsReadScheduler;
}

function useMarkAsDeliveredScheduler(_a, _b) {
  var isConnected = _a.isConnected;
  var logger = _b.logger;
  var markAsDeliveredScheduler = useMemo(function () {
    return schedulerFactory({
      logger: logger,
      cb: function (channel) {
        try {
          channel.markAsDelivered();
        } catch (error) {
          logger.warning('Channel: Mark as delivered failed', {
            channel: channel,
            error: error
          });
        }
      }
    });
  }, []);
  useEffect(function () {
    // for simplicity, we clear the queue when the connection is lost
    if (!isConnected) {
      markAsDeliveredScheduler.clear();
    }
  }, [isConnected]);
  useUnmount(function () {
    markAsDeliveredScheduler.clear();
  });
  return markAsDeliveredScheduler;
}

function SendbirdProvider(props) {
  var localConfigs = uikitConfigMapper({
    legacyConfig: {
      replyType: props.replyType,
      isMentionEnabled: props.isMentionEnabled,
      isReactionEnabled: props.isReactionEnabled,
      disableUserProfile: props.disableUserProfile,
      isVoiceMessageEnabled: props.isVoiceMessageEnabled,
      isTypingIndicatorEnabledOnChannelList: props.isTypingIndicatorEnabledOnChannelList,
      isMessageReceiptStatusEnabledOnChannelList: props.isMessageReceiptStatusEnabledOnChannelList,
      showSearchIcon: props.showSearchIcon
    },
    uikitOptions: props.uikitOptions
  });
  return /*#__PURE__*/React__default.createElement(UIKitConfigProvider, {
    localConfigs: {
      common: localConfigs === null || localConfigs === void 0 ? void 0 : localConfigs.common,
      groupChannel: {
        channel: localConfigs === null || localConfigs === void 0 ? void 0 : localConfigs.groupChannel,
        channelList: localConfigs === null || localConfigs === void 0 ? void 0 : localConfigs.groupChannelList,
        setting: localConfigs === null || localConfigs === void 0 ? void 0 : localConfigs.groupChannelSettings
      },
      openChannel: {
        channel: localConfigs === null || localConfigs === void 0 ? void 0 : localConfigs.openChannel
      }
    }
  }, /*#__PURE__*/React__default.createElement(SendbirdSDK, props));
}
var SendbirdSDK = function (_a) {
  var _b, _c, _d;
  var appId = _a.appId,
    userId = _a.userId,
    children = _a.children,
    _e = _a.accessToken,
    accessToken = _e === void 0 ? '' : _e,
    _f = _a.customApiHost,
    customApiHost = _f === void 0 ? '' : _f,
    _g = _a.customWebSocketHost,
    customWebSocketHost = _g === void 0 ? '' : _g,
    _h = _a.configureSession,
    configureSession = _h === void 0 ? null : _h,
    _j = _a.theme,
    theme = _j === void 0 ? 'light' : _j,
    _k = _a.config,
    config = _k === void 0 ? {} : _k,
    _l = _a.nickname,
    nickname = _l === void 0 ? '' : _l,
    _m = _a.colorSet,
    colorSet = _m === void 0 ? null : _m,
    _o = _a.stringSet,
    stringSet = _o === void 0 ? null : _o,
    _p = _a.dateLocale,
    dateLocale = _p === void 0 ? null : _p,
    _q = _a.profileUrl,
    profileUrl = _q === void 0 ? '' : _q,
    voiceRecord = _a.voiceRecord,
    _r = _a.userListQuery,
    userListQuery = _r === void 0 ? null : _r,
    _s = _a.imageCompression,
    imageCompression = _s === void 0 ? {} : _s,
    _t = _a.allowProfileEdit,
    allowProfileEdit = _t === void 0 ? false : _t,
    _u = _a.disableMarkAsDelivered,
    disableMarkAsDelivered = _u === void 0 ? false : _u,
    _v = _a.renderUserProfile,
    renderUserProfile = _v === void 0 ? null : _v,
    _w = _a.onUserProfileMessage,
    onUserProfileMessage = _w === void 0 ? null : _w,
    _x = _a.breakpoint,
    breakpoint = _x === void 0 ? false : _x,
    _y = _a.isUserIdUsedForNickname,
    isUserIdUsedForNickname = _y === void 0 ? true : _y,
    sdkInitParams = _a.sdkInitParams,
    customExtensionParams = _a.customExtensionParams,
    _z = _a.isMultipleFilesMessageEnabled,
    isMultipleFilesMessageEnabled = _z === void 0 ? false : _z,
    eventHandlers = _a.eventHandlers;
  var _0 = config.logLevel,
    logLevel = _0 === void 0 ? '' : _0,
    _1 = config.userMention,
    userMention = _1 === void 0 ? {} : _1,
    _2 = config.isREMUnitEnabled,
    isREMUnitEnabled = _2 === void 0 ? false : _2,
    customPubSub = config.pubSub;
  var isMobile = useMediaQueryContext().isMobile;
  var _3 = useState(LoggerFactory(logLevel)),
    logger = _3[0],
    setLogger = _3[1];
  var pubSub = useState(function () {
    return customPubSub !== null && customPubSub !== void 0 ? customPubSub : pubSubFactory();
  })[0];
  var _4 = useReducer(reducer$1, initialState$1),
    sdkStore = _4[0],
    sdkDispatcher = _4[1];
  var _5 = useReducer(reducer, initialState),
    userStore = _5[0],
    userDispatcher = _5[1];
  var _6 = useUIKitConfig(),
    configs = _6.configs,
    configsWithAppAttr = _6.configsWithAppAttr,
    initDashboardConfigs = _6.initDashboardConfigs;
  var sdkInitialized = sdkStore.initialized;
  var sdk = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.sdk;
  var _7 = (_b = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) !== null && _b !== void 0 ? _b : {},
    uploadSizeLimit = _7.uploadSizeLimit,
    multipleFilesMessageFileCountLimit = _7.multipleFilesMessageFileCountLimit;
  useTheme(colorSet);
  var reconnect = useConnect({
    appId: appId,
    userId: userId,
    accessToken: accessToken,
    isUserIdUsedForNickname: isUserIdUsedForNickname,
    isMobile: isMobile
  }, {
    logger: logger,
    nickname: nickname,
    profileUrl: profileUrl,
    configureSession: configureSession,
    customApiHost: customApiHost,
    customWebSocketHost: customWebSocketHost,
    sdkInitParams: sdkInitParams,
    customExtensionParams: customExtensionParams,
    sdk: sdk,
    sdkDispatcher: sdkDispatcher,
    userDispatcher: userDispatcher,
    initDashboardConfigs: initDashboardConfigs
  });
  useUnmount(function () {
    if (typeof sdk.disconnect === 'function') {
      disconnectSdk({
        logger: logger,
        sdkDispatcher: sdkDispatcher,
        userDispatcher: userDispatcher,
        sdk: sdk
      });
    }
  }, [sdk.disconnect]);
  // to create a pubsub to communicate between parent and child
  useEffect(function () {
    setLogger(LoggerFactory(logLevel));
  }, [logLevel]);
  useAppendDomNode(['sendbird-modal-root', 'sendbird-dropdown-portal', 'sendbird-emoji-list-portal'], 'body');
  // should move to reducer
  var _8 = useState(theme),
    currentTheme = _8[0],
    setCurrentTheme = _8[1];
  useEffect(function () {
    setCurrentTheme(theme);
  }, [theme]);
  useEffect(function () {
    var body = document.querySelector('body');
    body.classList.remove('sendbird-experimental__rem__units');
    if (isREMUnitEnabled) {
      body.classList.add('sendbird-experimental__rem__units');
    }
  }, [isREMUnitEnabled]);
  // add-remove theme from body
  useEffect(function () {
    logger.info('Setup theme', "Theme: ".concat(currentTheme));
    try {
      var body = document.querySelector('body');
      body.classList.remove('sendbird-theme--light');
      body.classList.remove('sendbird-theme--dark');
      body.classList.add("sendbird-theme--".concat(currentTheme || 'light'));
      logger.info('Finish setup theme');
      // eslint-disable-next-line no-empty
    } catch (e) {
      logger.warning('Setup theme failed', "".concat(e));
    }
    return function () {
      try {
        var body = document.querySelector('body');
        body.classList.remove('sendbird-theme--light');
        body.classList.remove('sendbird-theme--dark');
        // eslint-disable-next-line no-empty
      } catch (_a) {}
    };
  }, [currentTheme]);
  var isOnline = useOnlineStatus(sdkStore.sdk, logger);
  var markAsReadScheduler = useMarkAsReadScheduler({
    isConnected: isOnline
  }, {
    logger: logger
  });
  var markAsDeliveredScheduler = useMarkAsDeliveredScheduler({
    isConnected: isOnline
  }, {
    logger: logger
  });
  var localeStringSet = React__default.useMemo(function () {
    if (!stringSet) {
      return getStringSet('en');
    }
    return __assign(__assign({}, getStringSet('en')), stringSet);
  }, [stringSet]);
  /**
   * Feature Configuration - TODO
   * This will be moved into the UIKitConfigProvider, aftering Dashboard applies
   */
  var uikitMultipleFilesMessageLimit = useMemo(function () {
    return Math.min(DEFAULT_MULTIPLE_FILES_MESSAGE_LIMIT, multipleFilesMessageFileCountLimit !== null && multipleFilesMessageFileCountLimit !== void 0 ? multipleFilesMessageFileCountLimit : Number.MAX_SAFE_INTEGER);
  }, [multipleFilesMessageFileCountLimit]);
  var uikitUploadSizeLimit = useMemo(function () {
    return uploadSizeLimit;
  }, [uploadSizeLimit]);
  return /*#__PURE__*/React__default.createElement(SendbirdSdkContext.Provider, {
    value: {
      stores: {
        sdkStore: sdkStore,
        userStore: userStore
      },
      dispatchers: {
        sdkDispatcher: sdkDispatcher,
        userDispatcher: userDispatcher,
        reconnect: reconnect
      },
      config: {
        disableMarkAsDelivered: disableMarkAsDelivered,
        renderUserProfile: renderUserProfile,
        onUserProfileMessage: onUserProfileMessage,
        allowProfileEdit: allowProfileEdit,
        isOnline: isOnline,
        userId: userId,
        appId: appId,
        accessToken: accessToken,
        theme: currentTheme,
        setCurrentTheme: setCurrentTheme,
        setCurrenttheme: setCurrentTheme,
        isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,
        uikitUploadSizeLimit: uikitUploadSizeLimit,
        uikitMultipleFilesMessageLimit: uikitMultipleFilesMessageLimit,
        userListQuery: userListQuery,
        logger: logger,
        pubSub: pubSub,
        imageCompression: __assign({
          compressionRate: 0.7
        }, imageCompression),
        voiceRecord: {
          maxRecordingTime: (_c = voiceRecord === null || voiceRecord === void 0 ? void 0 : voiceRecord.maxRecordingTime) !== null && _c !== void 0 ? _c : VOICE_RECORDER_DEFAULT_MAX,
          minRecordingTime: (_d = voiceRecord === null || voiceRecord === void 0 ? void 0 : voiceRecord.minRecordingTime) !== null && _d !== void 0 ? _d : VOICE_RECORDER_DEFAULT_MIN
        },
        userMention: {
          maxMentionCount: (userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount) || 10,
          maxSuggestionCount: (userMention === null || userMention === void 0 ? void 0 : userMention.maxSuggestionCount) || 15
        },
        markAsReadScheduler: markAsReadScheduler,
        markAsDeliveredScheduler: markAsDeliveredScheduler,
        // From UIKitConfigProvider.localConfigs
        disableUserProfile: !configs.common.enableUsingDefaultUserProfile,
        isReactionEnabled: sdkInitialized && configsWithAppAttr(sdk).groupChannel.channel.enableReactions,
        isMentionEnabled: configs.groupChannel.channel.enableMention,
        isVoiceMessageEnabled: configs.groupChannel.channel.enableVoiceMessage,
        replyType: getCaseResolvedReplyType(configs.groupChannel.channel.replyType).upperCase,
        isTypingIndicatorEnabledOnChannelList: configs.groupChannel.channelList.enableTypingIndicator,
        isMessageReceiptStatusEnabledOnChannelList: configs.groupChannel.channelList.enableMessageReceiptStatus,
        showSearchIcon: sdkInitialized && configsWithAppAttr(sdk).groupChannel.setting.enableMessageSearch,
        // Remote configs set from dashboard by UIKit feature configuration
        groupChannel: {
          enableOgtag: sdkInitialized && configsWithAppAttr(sdk).groupChannel.channel.enableOgtag,
          enableTypingIndicator: configs.groupChannel.channel.enableTypingIndicator,
          enableDocument: configs.groupChannel.channel.input.enableDocument,
          threadReplySelectType: getCaseResolvedThreadReplySelectType(configs.groupChannel.channel.threadReplySelectType).lowerCase
        },
        openChannel: {
          enableOgtag: sdkInitialized && configsWithAppAttr(sdk).openChannel.channel.enableOgtag,
          enableDocument: configs.openChannel.channel.input.enableDocument
        }
      },
      eventHandlers: eventHandlers
    }
  }, /*#__PURE__*/React__default.createElement(MediaQueryProvider, {
    logger: logger,
    breakpoint: breakpoint
  }, /*#__PURE__*/React__default.createElement(LocalizationProvider, {
    stringSet: localeStringSet,
    dateLocale: dateLocale
  }, /*#__PURE__*/React__default.createElement(VoiceMessageProvider, {
    isVoiceMessageEnabled: configs.groupChannel.channel.enableVoiceMessage
  }, /*#__PURE__*/React__default.createElement(GlobalModalProvider, null, children)))));
};

export { SendbirdProvider, SendbirdProvider as default };
//# sourceMappingURL=SendbirdProvider.js.map
