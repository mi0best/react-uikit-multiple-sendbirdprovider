'use strict';

var React = require('react');
var pubSub_topics = require('./pubSub/topics.js');
var utils = require('./utils-9193a195.js');
var index = require('./index-3448df64.js');
var utils_message_getOutgoingMessageState = require('./utils/message/getOutgoingMessageState.js');

var RESET_MESSAGES = 'RESET_MESSAGES';
var FETCH_INITIAL_MESSAGES_START = 'FETCH_INITIAL_MESSAGES_START';
var FETCH_INITIAL_MESSAGES_SUCCESS = 'FETCH_INITIAL_MESSAGES_SUCCESS';
var FETCH_INITIAL_MESSAGES_FAILURE = 'FETCH_INITIAL_MESSAGES_FAILURE';
var FETCH_PREV_MESSAGES_SUCCESS = 'FETCH_PREV_MESSAGES_SUCCESS';
var FETCH_PREV_MESSAGES_FAILURE = 'FETCH_PREV_MESSAGES_FAILURE';
var FETCH_NEXT_MESSAGES_SUCCESS = 'FETCH_NEXT_MESSAGES_SUCCESS';
var FETCH_NEXT_MESSAGES_FAILURE = 'FETCH_NEXT_MESSAGES_FAILURE';
var SEND_MESSAGE_START = 'SEND_MESSAGE_START';
var SEND_MESSAGE_SUCCESS = 'SEND_MESSAGE_SUCCESS';
var SEND_MESSAGE_FAILURE = 'SEND_MESSAGE_FAILURE';
var RESEND_MESSAGE_START = 'RESEND_MESSAGE_START';
var ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';
var ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';
var ON_MESSAGE_THREAD_INFO_UPDATED = 'ON_MESSAGE_THREAD_INFO_UPDATED';
var ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';
var ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';
var SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';
var SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';
var MARK_AS_READ = 'MARK_AS_READ';
var ON_REACTION_UPDATED = 'ON_REACTION_UPDATED';
var SET_EMOJI_CONTAINER = 'SET_EMOJI_CONTAINER';
var MESSAGE_LIST_PARAMS_CHANGED = 'MESSAGE_LIST_PARAMS_CHANGED';
var ON_FILE_INFO_UPLOADED = 'ON_FILE_INFO_UPLOADED';

var channelActions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    RESET_MESSAGES: RESET_MESSAGES,
    FETCH_INITIAL_MESSAGES_START: FETCH_INITIAL_MESSAGES_START,
    FETCH_INITIAL_MESSAGES_SUCCESS: FETCH_INITIAL_MESSAGES_SUCCESS,
    FETCH_INITIAL_MESSAGES_FAILURE: FETCH_INITIAL_MESSAGES_FAILURE,
    FETCH_PREV_MESSAGES_SUCCESS: FETCH_PREV_MESSAGES_SUCCESS,
    FETCH_PREV_MESSAGES_FAILURE: FETCH_PREV_MESSAGES_FAILURE,
    FETCH_NEXT_MESSAGES_SUCCESS: FETCH_NEXT_MESSAGES_SUCCESS,
    FETCH_NEXT_MESSAGES_FAILURE: FETCH_NEXT_MESSAGES_FAILURE,
    SEND_MESSAGE_START: SEND_MESSAGE_START,
    SEND_MESSAGE_SUCCESS: SEND_MESSAGE_SUCCESS,
    SEND_MESSAGE_FAILURE: SEND_MESSAGE_FAILURE,
    RESEND_MESSAGE_START: RESEND_MESSAGE_START,
    ON_MESSAGE_RECEIVED: ON_MESSAGE_RECEIVED,
    ON_MESSAGE_UPDATED: ON_MESSAGE_UPDATED,
    ON_MESSAGE_THREAD_INFO_UPDATED: ON_MESSAGE_THREAD_INFO_UPDATED,
    ON_MESSAGE_DELETED: ON_MESSAGE_DELETED,
    ON_MESSAGE_DELETED_BY_REQ_ID: ON_MESSAGE_DELETED_BY_REQ_ID,
    SET_CURRENT_CHANNEL: SET_CURRENT_CHANNEL,
    SET_CHANNEL_INVALID: SET_CHANNEL_INVALID,
    MARK_AS_READ: MARK_AS_READ,
    ON_REACTION_UPDATED: ON_REACTION_UPDATED,
    SET_EMOJI_CONTAINER: SET_EMOJI_CONTAINER,
    MESSAGE_LIST_PARAMS_CHANGED: MESSAGE_LIST_PARAMS_CHANGED,
    ON_FILE_INFO_UPLOADED: ON_FILE_INFO_UPLOADED
});

exports.PublishingModuleType = void 0;
(function (PublishingModuleType) {
  PublishingModuleType["CHANNEL"] = "CHANNEL";
  PublishingModuleType["THREAD"] = "THREAD";
})(exports.PublishingModuleType || (exports.PublishingModuleType = {}));

var getNicknamesMapFromMembers = function (members) {
  if (members === void 0) {
    members = [];
  }
  var nicknamesMap = new Map();
  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {
    var _a = members[memberIndex],
      userId = _a.userId,
      nickname = _a.nickname;
    nicknamesMap.set(userId, nickname);
  }
  return nicknamesMap;
};
var getParentMessageFrom = function (message) {
  if (!message) {
    return null;
  }
  if (isParentMessage(message)) {
    return message;
  }
  if (isThreadMessage(message)) {
    return (message === null || message === void 0 ? void 0 : message.parentMessage) || null;
  }
  return null;
};
var isParentMessage = function (message) {
  return (message === null || message === void 0 ? void 0 : message.parentMessage) === null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && !(message === null || message === void 0 ? void 0 : message.parentMessageId);
};
var isThreadMessage = function (message) {
  return (message === null || message === void 0 ? void 0 : message.parentMessage) !== null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0 && (message === null || message === void 0 ? void 0 : message.threadInfo) === null;
};
var isAboutSame = function (a, b, px) {
  return Math.abs(a - b) <= px;
};
var isEmpty = function (val) {
  return val === null || val === undefined;
};
// Some Ids return string and number inconsistently
// only use to comapre IDs
function compareIds(a, b) {
  if (isEmpty(a) || isEmpty(b)) {
    return false;
  }
  var aString = a.toString();
  var bString = b.toString();
  return aString === bString;
}
var getMessageCreatedAt = function (message) {
  return index.format(message.createdAt, 'p');
};
var isReadMessage = function (channel, message) {
  return utils_message_getOutgoingMessageState.getOutgoingMessageState(channel, message) === utils_message_getOutgoingMessageState.OutgoingMessageStates.READ;
};
var isSameGroup = function (message, comparingMessage, currentChannel) {
  var _a, _b, _c, _d;
  if (!(message && comparingMessage && message.messageType && message.messageType !== 'admin' && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin' && (message === null || message === void 0 ? void 0 : message.sender) && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) && (message === null || message === void 0 ? void 0 : message.createdAt) && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.createdAt) && ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.userId) && ((_b = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _b === void 0 ? void 0 : _b.userId))) {
    return false;
  }
  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && ((_c = message === null || message === void 0 ? void 0 : message.sender) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _d === void 0 ? void 0 : _d.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage);
};
var compareMessagesForGrouping = function (prevMessage, currMessage, nextMessage, currentChannel, replyType) {
  if (replyType === 'THREAD' && (currMessage === null || currMessage === void 0 ? void 0 : currMessage.threadInfo)) {
    return [false, false];
  }
  var sendingStatus = (currMessage === null || currMessage === void 0 ? void 0 : currMessage.sendingStatus) || '';
  var isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';
  return [isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable, isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable];
};
var scrollIntoLast = function (intialTry) {
  if (intialTry === void 0) {
    intialTry = 0;
  }
  var MAX_TRIES = 10;
  var currentTry = intialTry;
  if (currentTry > MAX_TRIES) {
    return;
  }
  try {
    var scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');
    // eslint-disable-next-line no-multi-assign
    scrollDOM.scrollTop = scrollDOM.scrollHeight;
  } catch (error) {
    setTimeout(function () {
      scrollIntoLast(currentTry + 1);
    }, 500 * currentTry);
  }
};

/**
 * pubSub is used instead of messagesDispatcher to avoid redundantly calling
 * because this useSendMultipleFilesMessage is used in the Channel and Thread both
 */
var useSendMultipleFilesMessage = function (_a, _b) {
  var currentChannel = _a.currentChannel,
    onBeforeSendMultipleFilesMessage = _a.onBeforeSendMultipleFilesMessage,
    publishingModules = _a.publishingModules;
  var logger = _b.logger,
    pubSub = _b.pubSub,
    scrollRef = _b.scrollRef;
  var sendMessage = React.useCallback(function (files, quoteMessage) {
    return new Promise(function (resolve, reject) {
      if (!currentChannel) {
        logger.warning('Channel: Sending MFm failed, because currentChannel is null.', {
          currentChannel: currentChannel
        });
        reject();
      }
      if (files.length <= 1) {
        logger.warning('Channel: Sending MFM failed, because there are no multiple files.', {
          files: files
        });
        reject();
      }
      var messageParams = {
        fileInfoList: files.map(function (file) {
          return {
            file: file,
            fileName: file.name,
            fileSize: file.size,
            mimeType: file.type
          };
        })
      };
      if (quoteMessage) {
        messageParams.isReplyToChannel = true;
        messageParams.parentMessageId = quoteMessage.messageId;
      }
      if (typeof onBeforeSendMultipleFilesMessage === 'function') {
        messageParams = onBeforeSendMultipleFilesMessage(files, quoteMessage);
      }
      logger.info('Channel: Start sending MFM', {
        messageParams: messageParams
      });
      try {
        currentChannel.sendMultipleFilesMessage(messageParams)
        /**
         * We don't operate the onFileUploaded event for now
         * until we will add UI/UX for it
         */.onFileUploaded(function (requestId, index, uploadableFileInfo, error) {
          logger.info('Channel: onFileUploaded during sending MFM', {
            requestId: requestId,
            index: index,
            error: error,
            uploadableFileInfo: uploadableFileInfo
          });
          pubSub.publish(pubSub_topics.PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, {
            response: {
              channelUrl: currentChannel.url,
              requestId: requestId,
              index: index,
              uploadableFileInfo: uploadableFileInfo,
              error: error
            },
            publishingModules: publishingModules
          });
        }).onPending(function (pendingMessage) {
          logger.info('Channel: in progress of sending MFM', {
            pendingMessage: pendingMessage,
            fileInfoList: messageParams.fileInfoList
          });
          pubSub.publish(pubSub_topics.PUBSUB_TOPICS.SEND_MESSAGE_START, {
            message: pendingMessage,
            channel: currentChannel,
            publishingModules: publishingModules
          });
          // We need this delay because rendering MFM takes time due to large image files.
          setTimeout(function () {
            if (scrollRef && publishingModules.includes(exports.PublishingModuleType.CHANNEL)) {
              utils.scrollIntoLast(0, scrollRef);
            }
            if (publishingModules.includes(exports.PublishingModuleType.THREAD)) {
              scrollIntoLast(0);
            }
          }, 100);
        }).onFailed(function (error, failedMessage) {
          logger.error('Channel: Sending MFM failed.', {
            error: error,
            failedMessage: failedMessage
          });
          pubSub.publish(pubSub_topics.PUBSUB_TOPICS.SEND_MESSAGE_FAILED, {
            channel: currentChannel,
            message: failedMessage,
            publishingModules: publishingModules
          });
          reject(error);
        }).onSucceeded(function (succeededMessage) {
          logger.info('Channel: Sending voice message success!', {
            succeededMessage: succeededMessage
          });
          pubSub.publish(pubSub_topics.PUBSUB_TOPICS.SEND_FILE_MESSAGE, {
            channel: currentChannel,
            message: succeededMessage,
            publishingModules: publishingModules
          });
          // We need this delay because rendering MFM takes time due to large image files.
          setTimeout(function () {
            if (scrollRef && publishingModules.includes(exports.PublishingModuleType.CHANNEL)) {
              utils.scrollIntoLast(0, scrollRef);
            }
            if (publishingModules.includes(exports.PublishingModuleType.THREAD)) {
              scrollIntoLast(0);
            }
          }, 100);
          resolve(succeededMessage);
        });
      } catch (error) {
        logger.error('Channel: Sending MFM failed.', {
          error: error
        });
        reject(error);
      }
    });
  }, [currentChannel, onBeforeSendMultipleFilesMessage, publishingModules]);
  return [sendMessage];
};

exports.FETCH_INITIAL_MESSAGES_FAILURE = FETCH_INITIAL_MESSAGES_FAILURE;
exports.FETCH_INITIAL_MESSAGES_START = FETCH_INITIAL_MESSAGES_START;
exports.FETCH_INITIAL_MESSAGES_SUCCESS = FETCH_INITIAL_MESSAGES_SUCCESS;
exports.FETCH_NEXT_MESSAGES_FAILURE = FETCH_NEXT_MESSAGES_FAILURE;
exports.FETCH_NEXT_MESSAGES_SUCCESS = FETCH_NEXT_MESSAGES_SUCCESS;
exports.FETCH_PREV_MESSAGES_FAILURE = FETCH_PREV_MESSAGES_FAILURE;
exports.FETCH_PREV_MESSAGES_SUCCESS = FETCH_PREV_MESSAGES_SUCCESS;
exports.MARK_AS_READ = MARK_AS_READ;
exports.MESSAGE_LIST_PARAMS_CHANGED = MESSAGE_LIST_PARAMS_CHANGED;
exports.ON_FILE_INFO_UPLOADED = ON_FILE_INFO_UPLOADED;
exports.ON_MESSAGE_DELETED = ON_MESSAGE_DELETED;
exports.ON_MESSAGE_DELETED_BY_REQ_ID = ON_MESSAGE_DELETED_BY_REQ_ID;
exports.ON_MESSAGE_RECEIVED = ON_MESSAGE_RECEIVED;
exports.ON_MESSAGE_THREAD_INFO_UPDATED = ON_MESSAGE_THREAD_INFO_UPDATED;
exports.ON_MESSAGE_UPDATED = ON_MESSAGE_UPDATED;
exports.ON_REACTION_UPDATED = ON_REACTION_UPDATED;
exports.RESEND_MESSAGE_START = RESEND_MESSAGE_START;
exports.RESET_MESSAGES = RESET_MESSAGES;
exports.SEND_MESSAGE_FAILURE = SEND_MESSAGE_FAILURE;
exports.SEND_MESSAGE_START = SEND_MESSAGE_START;
exports.SEND_MESSAGE_SUCCESS = SEND_MESSAGE_SUCCESS;
exports.SET_CHANNEL_INVALID = SET_CHANNEL_INVALID;
exports.SET_CURRENT_CHANNEL = SET_CURRENT_CHANNEL;
exports.SET_EMOJI_CONTAINER = SET_EMOJI_CONTAINER;
exports.channelActions = channelActions;
exports.compareIds = compareIds;
exports.compareMessagesForGrouping = compareMessagesForGrouping;
exports.getNicknamesMapFromMembers = getNicknamesMapFromMembers;
exports.getParentMessageFrom = getParentMessageFrom;
exports.isAboutSame = isAboutSame;
exports.scrollIntoLast = scrollIntoLast;
exports.useSendMultipleFilesMessage = useSendMultipleFilesMessage;
//# sourceMappingURL=useSendMultipleFilesMessage-d6a3d5cf.js.map
