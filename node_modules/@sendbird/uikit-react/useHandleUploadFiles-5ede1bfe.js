import React__default, { useRef, useState, useEffect, useCallback } from 'react';
import { u as useLocalization } from './LocalizationContext-287ee149.js';
import { useVoicePlayer } from './VoicePlayer/useVoicePlayer.js';
import { useVoiceRecorder, VoiceRecorderStatus } from './VoiceRecorder/useVoiceRecorder.js';
import { d as isDisabledBecauseFrozen, e as isDisabledBecauseMuted } from './utils-aa4086dc.js';
import { V as VoiceMessageInputStatus, a as VoiceMessageInput } from './index-493689bd.js';
import { Modal, ModalFooter } from './ui/Modal.js';
import Button from './ui/Button.js';
import { useSendbirdStateContext } from './useSendbirdStateContext.js';
import { a as VOICE_RECORDER_DEFAULT_MIN } from './consts-d9c5f25a.js';
import { a as VOICE_PLAYER_STATUS } from './index-e04159fe.js';
import { u as uuidv4 } from './uuid-c15b8b3b.js';
import { B as ButtonTypes, a as ButtonSizes } from './types-9d43ac6e.js';
import { h as isImage } from './index-776554c0.js';
import { useGlobalModalContext } from './hooks/useModal.js';
import './tslib.es6-c2fb729e.js';
import './index-92741c7e.js';

var VoiceMessageInputWrapper = function (_a) {
  var _b;
  var channel = _a.channel,
    onCancelClick = _a.onCancelClick,
    onSubmitClick = _a.onSubmitClick;
  var uuid = useRef(uuidv4()).current;
  var _c = useState(null),
    audioFile = _c[0],
    setAudioFile = _c[1];
  var _d = useState(VoiceMessageInputStatus.READY_TO_RECORD),
    voiceInputState = _d[0],
    setVoiceInputState = _d[1];
  var _e = useState(false),
    isSubmitted = _e[0],
    setSubmit = _e[1];
  var _f = useState(false),
    isDisabled = _f[0],
    setDisabled = _f[1];
  var _g = useState(false),
    showModal = _g[0],
    setShowModal = _g[1];
  var stringSet = useLocalization().stringSet;
  var config = useSendbirdStateContext().config;
  var minRecordingTime = ((_b = config === null || config === void 0 ? void 0 : config.voiceRecord) === null || _b === void 0 ? void 0 : _b.minRecordingTime) || VOICE_RECORDER_DEFAULT_MIN;
  var _h = useVoiceRecorder({
      onRecordingStarted: function () {
        setVoiceInputState(VoiceMessageInputStatus.RECORDING);
      },
      onRecordingEnded: function (audioFile) {
        setAudioFile(audioFile);
      }
    }),
    start = _h.start,
    stop = _h.stop,
    cancel = _h.cancel,
    recordingTime = _h.recordingTime,
    recordingStatus = _h.recordingStatus,
    recordingLimit = _h.recordingLimit;
  var voicePlayer = useVoicePlayer({
    channelUrl: channel === null || channel === void 0 ? void 0 : channel.url,
    key: uuid,
    audioFile: audioFile
  });
  var play = voicePlayer.play,
    pause = voicePlayer.pause,
    playbackTime = voicePlayer.playbackTime,
    playingStatus = voicePlayer.playingStatus;
  var stopVoicePlayer = voicePlayer.stop;
  // disabled state: muted & frozen
  useEffect(function () {
    if (isDisabledBecauseFrozen(channel) || isDisabledBecauseMuted(channel)) {
      setDisabled(true);
    } else {
      setDisabled(false);
    }
  }, [channel === null || channel === void 0 ? void 0 : channel.myRole, channel === null || channel === void 0 ? void 0 : channel.isFrozen, channel === null || channel === void 0 ? void 0 : channel.myMutedState]);
  // call onSubmitClick when submit button is clicked and recorded audio file is created
  useEffect(function () {
    if (isSubmitted && audioFile) {
      onSubmitClick(audioFile, recordingTime);
      setSubmit(false);
      setAudioFile(null);
    }
  }, [isSubmitted, audioFile, recordingTime]);
  // operate which control button should be displayed
  useEffect(function () {
    if (audioFile) {
      if (recordingTime < minRecordingTime) {
        setVoiceInputState(VoiceMessageInputStatus.READY_TO_RECORD);
        setAudioFile(null);
      } else if (playingStatus === VOICE_PLAYER_STATUS.PLAYING) {
        setVoiceInputState(VoiceMessageInputStatus.PLAYING);
      } else {
        setVoiceInputState(VoiceMessageInputStatus.READY_TO_PLAY);
      }
    }
  }, [audioFile, recordingTime, playingStatus]);
  return /*#__PURE__*/React__default.createElement("div", {
    className: "sendbird-voice-message-input-wrapper"
  }, /*#__PURE__*/React__default.createElement(VoiceMessageInput, {
    currentValue: recordingStatus === VoiceRecorderStatus.COMPLETED ? playbackTime : recordingTime,
    maximumValue: recordingStatus === VoiceRecorderStatus.COMPLETED ? recordingTime : recordingLimit,
    currentType: voiceInputState,
    onCancelClick: function () {
      onCancelClick();
      cancel();
      stopVoicePlayer();
    },
    onSubmitClick: function () {
      if (isDisabled) {
        setShowModal(true);
        setVoiceInputState(VoiceMessageInputStatus.READY_TO_RECORD);
      } else {
        stop();
        pause();
        setSubmit(true);
      }
    },
    onControlClick: function (type) {
      switch (type) {
        case VoiceMessageInputStatus.READY_TO_RECORD:
          {
            stopVoicePlayer();
            start();
            break;
          }
        case VoiceMessageInputStatus.RECORDING:
          {
            if (recordingTime >= minRecordingTime && !isDisabled) {
              stop();
            } else if (isDisabled) {
              cancel();
              setShowModal(true);
              setVoiceInputState(VoiceMessageInputStatus.READY_TO_RECORD);
            } else {
              cancel();
              setVoiceInputState(VoiceMessageInputStatus.READY_TO_RECORD);
            }
            break;
          }
        case VoiceMessageInputStatus.READY_TO_PLAY:
          {
            play();
            break;
          }
        case VoiceMessageInputStatus.PLAYING:
          {
            pause();
            break;
          }
      }
    }
  }), showModal && /*#__PURE__*/React__default.createElement(Modal, {
    className: "sendbird-voice-message-input-wrapper-alert",
    titleText: isDisabledBecauseMuted(channel) ? stringSet.MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_MUTED : stringSet.MODAL__VOICE_MESSAGE_INPUT_DISABLED__TITLE_FROZEN,
    hideFooter: true,
    isCloseOnClickOutside: true,
    onCancel: function () {
      setShowModal(false);
      onCancelClick();
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "sendbird-voice-message-input-wrapper-alert__body"
  }, /*#__PURE__*/React__default.createElement(Button, {
    className: "sendbird-voice-message-input-wrapper-alert__body__ok-button",
    type: ButtonTypes.PRIMARY,
    size: ButtonSizes.BIG,
    onClick: function () {
      setShowModal(false);
      onCancelClick();
    }
  }, stringSet.BUTTON__OK))));
};

var useHandleUploadFiles = function (_a, _b) {
  var sendFileMessage = _a.sendFileMessage,
    sendMultipleFilesMessage = _a.sendMultipleFilesMessage,
    quoteMessage = _a.quoteMessage;
  var logger = _b.logger;
  var stringSet = useLocalization().stringSet;
  var config = useSendbirdStateContext().config;
  var uikitUploadSizeLimit = config === null || config === void 0 ? void 0 : config.uikitUploadSizeLimit;
  var uikitMultipleFilesMessageLimit = config === null || config === void 0 ? void 0 : config.uikitMultipleFilesMessageLimit;
  var openModal = useGlobalModalContext().openModal;
  var handleUploadFiles = useCallback(function (fileList) {
    var files = Array.from(fileList);
    // Validate Paremeters
    if (!sendFileMessage || !sendMultipleFilesMessage) {
      logger.warning('Channel|useHandleUploadFiles: required functions are undefined', {
        sendFileMessage: sendFileMessage,
        sendMultipleFilesMessage: sendMultipleFilesMessage
      });
      return;
    }
    if (files.length === 0) {
      logger.warning('Channel|useHandleUploadFiles: given file list is empty.', {
        files: files
      });
      return;
    }
    if (files.length > uikitMultipleFilesMessageLimit) {
      logger.info("Channel|useHandleUploadFiles: Cannot upload files more than ".concat(uikitMultipleFilesMessageLimit));
      openModal({
        modalProps: {
          titleText: "Up to ".concat(uikitMultipleFilesMessageLimit, " files can be attached."),
          hideFooter: true
        },
        childElement: function (_a) {
          var closeModal = _a.closeModal;
          return /*#__PURE__*/React__default.createElement(ModalFooter, {
            type: ButtonTypes.PRIMARY,
            submitText: stringSet.BUTTON__OK,
            hideCancelButton: true,
            onCancel: closeModal,
            onSubmit: closeModal
          });
        }
      });
      return;
    }
    if (files.some(function (file) {
      return file.size > uikitUploadSizeLimit;
    })) {
      // The default value of uikitUploadSizeLimit is 26MB
      logger.info("Channel|useHandleUploadFiles: Cannot upload file size exceeding ".concat(uikitUploadSizeLimit));
      var ONE_MiB = 1024 * 1024;
      openModal({
        modalProps: {
          titleText: "The maximum size per file is ".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB), " MB."),
          hideFooter: true
        },
        childElement: function (_a) {
          var closeModal = _a.closeModal;
          return /*#__PURE__*/React__default.createElement(ModalFooter, {
            type: ButtonTypes.PRIMARY,
            submitText: stringSet.BUTTON__OK,
            hideCancelButton: true,
            onCancel: closeModal,
            onSubmit: closeModal
          });
        }
      });
      return;
    }
    if (files.length === 1) {
      logger.info('Channel|useHandleUploadFiles: sending one file.');
      var file = files[0];
      sendFileMessage(file, quoteMessage);
    } else if (files.length > 1) {
      logger.info('Channel|useHandleUploadFiles: sending multiple files.');
      var imageFiles_1 = [];
      var otherFiles_1 = [];
      files.forEach(function (file) {
        if (isImage(file.type)) {
          imageFiles_1.push(file);
        } else {
          otherFiles_1.push(file);
        }
      });
      return otherFiles_1.reduce(function (previousPromise, item) {
        return previousPromise.then(function () {
          return sendFileMessage(item, quoteMessage);
        });
      }, function () {
        if (imageFiles_1.length === 0) {
          return Promise.resolve();
        } else if (imageFiles_1.length === 1) {
          return sendFileMessage(imageFiles_1[0], quoteMessage);
        } else {
          return sendMultipleFilesMessage(imageFiles_1, quoteMessage);
        }
      }());
    }
  }, [sendFileMessage, sendMultipleFilesMessage, quoteMessage]);
  return [handleUploadFiles];
};

export { VoiceMessageInputWrapper as V, useHandleUploadFiles as u };
//# sourceMappingURL=useHandleUploadFiles-5ede1bfe.js.map
