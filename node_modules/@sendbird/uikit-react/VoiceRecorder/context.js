import React__default, { useState, useEffect, useCallback, useContext, createContext } from 'react';
import { u as useLocalization } from '../LocalizationContext-287ee149.js';
import { Modal } from '../ui/Modal.js';
import { B as BROWSER_SUPPORT_MIME_TYPE_LIST, i as VOICE_RECORDER_AUDIO_BIT_RATE, c as VOICE_MESSAGE_FILE_NAME, d as VOICE_MESSAGE_MIME_TYPE } from '../consts-d9c5f25a.js';
import { useSendbirdStateContext } from '../useSendbirdStateContext.js';
import '../stringSet-6422c6b9.js';
import '../index-e4277f9c.js';
import 'react-dom';
import '../utils-6c50a6d1.js';
import '../tslib.es6-c2fb729e.js';
import '../index-09847c0f.js';
import '../index-04bd1a59.js';
import '../MediaQueryContext-114ca049.js';
import '../ui/IconButton.js';
import '../ui/Button.js';
import '../index-92741c7e.js';
import 'prop-types';
import '../types-9d43ac6e.js';
import '../ui/Icon.js';
import '../withSendbird.js';

var noop = function () {};
var Context = /*#__PURE__*/createContext({
  start: noop,
  stop: noop,
  isRecordable: false
});
var VoiceRecorderProvider = function (props) {
  var _a;
  var children = props.children;
  var config = useSendbirdStateContext().config;
  var logger = config.logger,
    isVoiceMessageEnabled = config.isVoiceMessageEnabled;
  var _b = useState(null),
    mediaRecorder = _b[0],
    setMediaRecorder = _b[1];
  var _c = useState(false),
    isRecordable = _c[0],
    setIsRecordable = _c[1];
  var _d = useState(false),
    permissionWarning = _d[0],
    setPermissionWarning = _d[1];
  var stringSet = useLocalization().stringSet;
  var checkPermission = function () {
    try {
      // Type '"microphone"' is not assignable to type 'PermissionName'.ts(2322)
      // this is typescript issue
      // https://github.com/microsoft/TypeScript/issues/33923
      // @ts-expect-error
      navigator.permissions.query({
        name: 'microphone'
      }).then(function (result) {
        if (result.state === 'denied') {
          logger.warning('VoiceRecorder: Permission denied.');
          setPermissionWarning(true);
        }
      });
    } catch (error) {
      logger.warning('VoiceRecorder: Failed to check permission.', error);
    }
  };
  var browserSupportMimeType = (_a = BROWSER_SUPPORT_MIME_TYPE_LIST.find(function (mimeType) {
    return MediaRecorder.isTypeSupported(mimeType);
  })) !== null && _a !== void 0 ? _a : '';
  if (!browserSupportMimeType) {
    logger.error('VoiceRecorder: Browser does not support mimeType', {
      mimmeTypes: BROWSER_SUPPORT_MIME_TYPE_LIST
    });
  }
  var _e = useState(null),
    webAudioUtils = _e[0],
    setWebAudioUtils = _e[1];
  useEffect(function () {
    if (isVoiceMessageEnabled && !webAudioUtils) {
      import('../WebAudioUtils-31f7c8eb.js').then(function (data) {
        setWebAudioUtils(data);
      });
    }
  }, []);
  var start = useCallback(function (eventHandler) {
    var _a, _b;
    if (isVoiceMessageEnabled && !webAudioUtils) {
      logger.error('VoiceRecorder: Recording audio processor is being loaded.');
      return;
    }
    logger.info('VoiceRecorder: Start recording.');
    if (mediaRecorder) {
      stop();
      logger.info('VoiceRecorder: Previous mediaRecorder is stopped.');
    }
    checkPermission();
    (_b = (_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) === null || _b === void 0 ? void 0 : _b.call(_a, {
      audio: true
    }).then(function (stream) {
      logger.info('VoiceRecorder: Succeeded getting media stream.', stream);
      setIsRecordable(true);
      var mediaRecorder = new MediaRecorder(stream, {
        mimeType: browserSupportMimeType,
        audioBitsPerSecond: VOICE_RECORDER_AUDIO_BIT_RATE
      });
      mediaRecorder.ondataavailable = function (e) {
        var _a, _b, _c;
        logger.info('VoiceRecorder: Succeeded getting an available data.', e.data);
        var audioFile = new File([e.data], VOICE_MESSAGE_FILE_NAME, {
          lastModified: new Date().getTime(),
          type: VOICE_MESSAGE_MIME_TYPE
        });
        webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.downsampleToWav(audioFile, function (buffer) {
          var mp3Buffer = webAudioUtils === null || webAudioUtils === void 0 ? void 0 : webAudioUtils.encodeMp3(buffer);
          var mp3blob = new Blob(mp3Buffer, {
            type: VOICE_MESSAGE_MIME_TYPE
          });
          var convertedAudioFile = new File([mp3blob], VOICE_MESSAGE_FILE_NAME, {
            lastModified: new Date().getTime(),
            type: VOICE_MESSAGE_MIME_TYPE
          });
          eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingEnded(convertedAudioFile);
          logger.info('VoiceRecorder: Succeeded converting audio file.', convertedAudioFile);
        });
        (_c = (_a = stream === null || stream === void 0 ? void 0 : stream.getAudioTracks) === null || _a === void 0 ? void 0 : (_b = _a.call(stream)).forEach) === null || _c === void 0 ? void 0 : _c.call(_b, function (track) {
          return track === null || track === void 0 ? void 0 : track.stop();
        });
        setIsRecordable(false);
      };
      mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.start();
      setMediaRecorder(mediaRecorder);
      eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.onRecordingStarted();
    }).catch(function (err) {
      logger.error('VoiceRecorder: Failed getting media stream.', err);
      setMediaRecorder(null);
    });
  }, [mediaRecorder, webAudioUtils]);
  var stop = useCallback(function () {
    // Stop recording
    mediaRecorder === null || mediaRecorder === void 0 ? void 0 : mediaRecorder.stop();
    setMediaRecorder(null);
    setIsRecordable(false);
    logger.info('VoiceRecorder: Stop recording.');
  }, [mediaRecorder]);
  return /*#__PURE__*/React__default.createElement(Context.Provider, {
    value: {
      start: start,
      stop: stop,
      isRecordable: isRecordable
    }
  }, children, permissionWarning && /*#__PURE__*/React__default.createElement(Modal, {
    hideFooter: true,
    onCancel: function () {
      return setPermissionWarning(false);
    }
  }, /*#__PURE__*/React__default.createElement(React__default.Fragment, null, stringSet.VOICE_RECORDING_PERMISSION_DENIED)));
};
var useVoiceRecorderContext = function () {
  return useContext(Context);
};
var index = {
  VoiceRecorderProvider: VoiceRecorderProvider,
  useVoiceRecorderContext: useVoiceRecorderContext
};

export { VoiceRecorderProvider, index as default, useVoiceRecorderContext };
//# sourceMappingURL=context.js.map
